//
// Copyright (c) 2025-2026 Jeff Garzik
//
// This file is part of the posixutils-rs project covered under
// the MIT License.  For the full license text, please see the LICENSE
// file in the root directory of this project.
// SPDX-License-Identifier: MIT
//
// Architecture-independent code generation interface
//

use crate::arch::lir::{Directive, EmitAsm, LirInst, Symbol};
use crate::arch::DEFAULT_LIR_BUFFER_CAPACITY;
use crate::ir::{Function, Initializer, Instruction, Module, Opcode};
use crate::target::Target;
use crate::types::{TypeModifiers, TypeTable};

// ============================================================================
// Shared Helper Types
// ============================================================================

/// Unary integer operation type
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UnaryOp {
    Neg,
    Not,
}

/// Byte-swap size
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BswapSize {
    B16,
    B32,
    B64,
}

// ============================================================================
// Constants
// ============================================================================

/// pcc version string for assembly header
pub const PCC_VERSION: &str = env!("CARGO_PKG_VERSION");

/// Generate header comment lines for assembly output (GCC-style)
/// Returns a vector of comment strings to be emitted
pub fn generate_header_comments(target: &Target) -> Vec<String> {
    let mut comments = Vec::new();

    // Target triple (normalized format)
    let os_triple = match target.os {
        crate::target::Os::Linux => "unknown-linux-gnu",
        crate::target::Os::MacOS => "apple-darwin",
        crate::target::Os::FreeBSD => "unknown-freebsd",
    };

    // Compiler identification with target
    comments.push(format!(
        "Generated by pcc {} ({}-{})",
        PCC_VERSION, target.arch, os_triple
    ));

    comments
}

/// Check if a function uses variadic arguments (contains VaStart opcode)
pub fn is_variadic_function(func: &Function) -> bool {
    for block in &func.blocks {
        for insn in &block.insns {
            if matches!(insn.op, Opcode::VaStart) {
                return true;
            }
        }
    }
    false
}

/// Escape a string for assembly output (.ascii/.asciz directives)
/// Non-printable and non-ASCII characters are escaped as octal byte sequences.
pub fn escape_string(s: &str) -> String {
    let mut result = String::new();
    for c in s.chars() {
        match c {
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            '\\' => result.push_str("\\\\"),
            '"' => result.push_str("\\\""),
            c if c.is_ascii_graphic() || c == ' ' => result.push(c),
            c => {
                // Escape non-printable as octal bytes (handles UTF-8 correctly)
                for byte in c.to_string().as_bytes() {
                    result.push_str(&format!("\\{:03o}", byte));
                }
            }
        }
    }
    result
}

// ============================================================================
// CodeGenBase - Generic Code Generation Infrastructure
// ============================================================================

/// Common code generation state shared between all architectures.
/// Generic over the LIR instruction type I, enabling type-safe architecture-specific
/// instruction buffers while sharing common infrastructure.
pub struct CodeGenBase<I: LirInst> {
    /// Target platform information
    pub target: Target,
    /// Output buffer for emitted assembly
    pub output: String,
    /// LIR instruction buffer for deferred emission and peephole optimization
    pub lir_buffer: Vec<I>,
    /// Current function name (for label generation)
    pub current_fn: String,
    /// Whether to emit basic unwind tables (cfi_startproc/cfi_endproc)
    pub emit_unwind_tables: bool,
    /// Last emitted source line (for avoiding duplicate .loc directives)
    pub last_debug_line: u32,
    /// Last emitted source file index
    pub last_debug_file: u16,
    /// Whether to emit debug info (.file/.loc directives)
    pub emit_debug: bool,
}

impl<I: LirInst + EmitAsm> CodeGenBase<I> {
    /// Create a new CodeGenBase for the given target
    pub fn new(target: Target) -> Self {
        Self {
            target,
            output: String::new(),
            lir_buffer: Vec::with_capacity(DEFAULT_LIR_BUFFER_CAPACITY),
            current_fn: String::new(),
            emit_unwind_tables: true,
            last_debug_line: 0,
            last_debug_file: 0,
            emit_debug: false,
        }
    }

    /// Push a LIR instruction to the buffer
    #[inline]
    pub fn push_lir(&mut self, inst: I) {
        self.lir_buffer.push(inst);
    }

    /// Push a directive (convenience method)
    #[inline]
    pub fn push_directive(&mut self, dir: Directive) {
        self.lir_buffer.push(I::from_directive(dir));
    }

    /// Emit all buffered LIR instructions to the output string
    pub fn emit_all(&mut self) {
        for inst in &self.lir_buffer {
            inst.emit(&self.target, &mut self.output);
        }
    }

    /// Clear LIR buffer (for reuse between functions)
    pub fn clear_lir(&mut self) {
        self.lir_buffer.clear();
    }

    /// Reset debug state for new module
    pub fn reset_debug_state(&mut self) {
        self.last_debug_line = 0;
        self.last_debug_file = 0;
    }

    /// Emit file header with compiler info
    pub fn emit_header(&mut self) {
        for comment in generate_header_comments(&self.target) {
            self.push_directive(Directive::Comment(comment));
        }
        self.push_directive(Directive::Text);
    }

    /// Emit .loc directive for source line tracking
    /// Returns true if a directive was emitted
    pub fn emit_loc(&mut self, insn: &Instruction) -> bool {
        if !self.emit_debug {
            return false;
        }
        if let Some(pos) = &insn.pos {
            let file = pos.stream + 1; // DWARF file indices start at 1
            let line = pos.line;
            if line != self.last_debug_line || file != self.last_debug_file {
                self.push_directive(Directive::loc(file.into(), line, pos.col.into()));
                self.last_debug_line = line;
                self.last_debug_file = file;
                return true;
            }
        }
        false
    }

    /// Emit a global variable definition
    pub fn emit_global(
        &mut self,
        name: &str,
        typ: &crate::types::TypeId,
        init: &Initializer,
        types: &TypeTable,
    ) {
        let size = types.size_bits(*typ) / 8;
        let size = if size == 0 { 8 } else { size }; // Default to 8 bytes

        // Check storage class - skip .globl for static
        let is_static = types.get(*typ).modifiers.contains(TypeModifiers::STATIC);

        // Get alignment from type info
        let align = types.alignment(*typ) as u32;

        // Use .comm for uninitialized external (non-static) globals
        let use_bss = matches!(init, Initializer::None) && !is_static;

        if use_bss {
            // Use .comm for uninitialized external globals
            self.push_directive(Directive::comm(name, size, align));
            return;
        }

        // Data section
        self.push_directive(Directive::Data);

        // Check if this is a local symbol (starts with '.')
        let is_local = name.starts_with('.');

        // Global visibility (if not static and not local)
        if !is_static && !is_local {
            self.push_directive(Directive::global(name));
        }

        // ELF-only type and size (handled by Directive::emit which skips on macOS)
        self.push_directive(Directive::type_object(name));
        self.push_directive(Directive::size(name, size));

        // Alignment
        if align > 1 {
            self.push_directive(Directive::Align(align.trailing_zeros()));
        }

        // Label - use local_label for names starting with '.'
        if is_local {
            self.push_directive(Directive::local_label(name));
        } else {
            self.push_directive(Directive::global_label(name));
        }

        // Emit initializer
        self.emit_initializer_data(init, size as usize);
    }

    /// Emit data for an initializer, recursively handling complex types
    pub fn emit_initializer_data(&mut self, init: &Initializer, size: usize) {
        match init {
            Initializer::None => {
                // Zero-fill
                self.push_directive(Directive::Zero(size as u32));
            }
            Initializer::Int(val) => match size {
                1 => self.push_directive(Directive::Byte(*val)),
                2 => self.push_directive(Directive::Short(*val)),
                4 => self.push_directive(Directive::Long(*val)),
                _ => self.push_directive(Directive::Quad(*val)),
            },
            Initializer::Float(val) => {
                if size == 4 {
                    // float - emit as 32-bit IEEE 754
                    let bits = (*val as f32).to_bits();
                    self.push_directive(Directive::Long(bits as i64));
                } else {
                    // double - emit as 64-bit IEEE 754
                    let bits = val.to_bits();
                    self.push_directive(Directive::Quad(bits as i64));
                }
            }
            Initializer::String(s) => {
                // Emit string as .ascii (without null terminator)
                // The array size will include space for null if needed
                self.push_directive(Directive::Ascii(escape_string(s)));
                // Zero-fill remaining bytes if array is larger than string
                let string_len = s.len() + 1; // +1 for null terminator
                if size > string_len {
                    self.push_directive(Directive::Zero((size - string_len) as u32));
                } else if size > s.len() {
                    // Need null terminator
                    self.push_directive(Directive::Byte(0));
                }
            }
            Initializer::Array {
                elem_size,
                total_size,
                elements,
            } => {
                // Emit array elements with gaps filled by zeros
                let mut current_offset = 0usize;

                for (offset, elem_init) in elements {
                    // Zero-fill gap before this element
                    if *offset > current_offset {
                        self.push_directive(Directive::Zero((*offset - current_offset) as u32));
                    }

                    // Emit element
                    self.emit_initializer_data(elem_init, *elem_size);
                    current_offset = offset + elem_size;
                }

                // Zero-fill remaining space
                if *total_size > current_offset {
                    self.push_directive(Directive::Zero((*total_size - current_offset) as u32));
                }
            }
            Initializer::Struct { total_size, fields } => {
                // Emit struct fields with gaps filled by zeros
                let mut current_offset = 0usize;

                for (offset, field_size, field_init) in fields {
                    // Zero-fill gap before this field
                    if *offset > current_offset {
                        self.push_directive(Directive::Zero((*offset - current_offset) as u32));
                    }

                    // Emit field
                    self.emit_initializer_data(field_init, *field_size);
                    current_offset = offset + field_size;
                }

                // Zero-fill remaining space
                if *total_size > current_offset {
                    self.push_directive(Directive::Zero((*total_size - current_offset) as u32));
                }
            }
            Initializer::SymAddr(name) => {
                let sym = if name.starts_with('.') {
                    Symbol::local(name.clone())
                } else {
                    Symbol::global(name.clone())
                };
                self.push_directive(Directive::QuadSym(sym));
            }
        }
    }

    /// Emit string literals to the rodata section
    pub fn emit_strings(&mut self, strings: &[(String, String)]) {
        if strings.is_empty() {
            return;
        }

        self.push_directive(Directive::Rodata);

        for (label, content) in strings {
            self.push_directive(Directive::local_label(label));
            self.push_directive(Directive::Asciz(escape_string(content)));
        }

        self.push_directive(Directive::Text);
    }
}

// ============================================================================
// CodeGenerator Trait
// ============================================================================

/// Trait for architecture-specific code generators
pub trait CodeGenerator {
    /// Generate assembly code for the given IR module
    fn generate(&mut self, module: &Module, types: &TypeTable) -> String;

    /// Set whether to emit basic unwind tables (cfi_startproc/cfi_endproc)
    fn set_emit_unwind_tables(&mut self, emit: bool);
}

/// Create a code generator for the given target with options
pub fn create_codegen_with_options(
    target: Target,
    emit_unwind_tables: bool,
) -> Box<dyn CodeGenerator> {
    use crate::target::Arch;

    let mut codegen: Box<dyn CodeGenerator> = match target.arch {
        Arch::X86_64 => Box::new(super::x86_64::codegen::X86_64CodeGen::new(target)),
        Arch::Aarch64 => Box::new(super::aarch64::codegen::Aarch64CodeGen::new(target)),
    };
    codegen.set_emit_unwind_tables(emit_unwind_tables);
    codegen
}
