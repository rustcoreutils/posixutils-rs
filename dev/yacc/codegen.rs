//
// Copyright (c) 2025-2026 Jeff Garzik
//
// This file is part of the posixutils-rs project covered under
// the MIT License.  For the full license text, please see the LICENSE
// file in the root directory of this project.
// SPDX-License-Identifier: MIT
//

//! C code generation for the yacc parser

use crate::diag;
use crate::error::YaccError;
use crate::grammar::{Grammar, EOF_SYMBOL, ERROR_SYMBOL};
use crate::lalr::{Action, LALRAutomaton};
use crate::Options;
use std::collections::BTreeMap;
use std::fs::File;
use std::io::{BufWriter, Write};

/// Packed/optimized parse tables for code generation and verification.
///
/// Per POSIX: "A parser generated by yacc shall never request an input symbol
/// from yylex() while in a state where the only actions other than the error
/// action are reductions by a single rule." (consistent state optimization)
#[derive(Debug)]
pub struct PackedTables {
    /// Main packed table (actions and gotos combined)
    pub table: Vec<i16>,
    /// Check array for validating table entries
    pub check: Vec<i16>,
    /// Per-state index into table for actions
    pub pact: Vec<i32>,
    /// Per-nonterminal index into table for gotos
    pub pgoto: Vec<i32>,
    /// Default reduction for each state (production_id + 1, or 0 for none)
    pub defact: Vec<u16>,
    /// Default goto for each nonterminal
    pub defgoto: Vec<i16>,
    /// Consistent states: true if only one reduce action exists (no shifts)
    pub consistent: Vec<bool>,
    /// Number of parser states (used for verification)
    pub num_states: usize,
}

/// Generate output files
pub fn generate(opts: &Options, grammar: &Grammar, lalr: &LALRAutomaton) -> Result<(), YaccError> {
    // Generate description file first if requested (per POSIX, should be produced even on errors)
    if opts.write_description {
        let desc_path = format!("{}.output", opts.file_prefix);
        generate_description_file(&desc_path, grammar, lalr)?;
    }

    // Generate code file
    let code_path = format!("{}.tab.c", opts.file_prefix);
    generate_code_file(&code_path, opts, grammar, lalr)?;

    // Generate header file if requested
    if opts.write_header {
        let header_path = format!("{}.tab.h", opts.file_prefix);
        generate_header_file(&header_path, opts, grammar)?;
    }

    Ok(())
}

/// Generate the main code file (y.tab.c)
fn generate_code_file(
    path: &str,
    opts: &Options,
    grammar: &Grammar,
    lalr: &LALRAutomaton,
) -> Result<(), YaccError> {
    let file = File::create(path)
        .map_err(|e| YaccError::Io(format!("cannot create '{}': {}", path, e)))?;
    let mut w = BufWriter::new(file);

    // Header comments
    writeln!(
        w,
        "/* A POSIX yacc parser, generated by yacc from posixutils-rs v{}.  */",
        env!("CARGO_PKG_VERSION")
    )?;
    writeln!(w)?;

    // YYDEBUG definition
    if opts.debug_enabled {
        writeln!(
            w,
            r#"#ifndef YYDEBUG
# define YYDEBUG 1
#endif
"#
        )?;
    } else {
        writeln!(
            w,
            r#"#ifndef YYDEBUG
# define YYDEBUG 0
#endif
"#
        )?;
    }

    // Standard includes
    writeln!(
        w,
        r#"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
"#
    )?;

    // Prologue code
    for code_block in &grammar.prologue {
        if !opts.omit_line_directives {
            writeln!(w, "#line {} \"{}\"", code_block.line, opts.grammar_file)?;
        }
        writeln!(w, "{}", code_block.code)?;
    }
    writeln!(w)?;

    // Token definitions
    generate_token_defines(&mut w, grammar, opts)?;
    writeln!(w)?;

    // YYSTYPE definition
    if let Some(ref union_def) = grammar.union_def {
        writeln!(w, "#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED")?;
        if !opts.omit_line_directives {
            writeln!(w, "#line {} \"{}\"", union_def.line, opts.grammar_file)?;
        }
        writeln!(w, "typedef union YYSTYPE")?;
        writeln!(w, "{}", union_def.code)?;
        writeln!(w, " YYSTYPE;")?;
        writeln!(w, "# define YYSTYPE_IS_DECLARED 1")?;
        writeln!(w, "#endif")?;
    } else {
        writeln!(
            w,
            r#"#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_DECLARED 1
#endif
"#
        )?;
    }

    // External declarations
    let prefix = &opts.sym_prefix;
    writeln!(w, "/* External declarations */")?;
    writeln!(w, "extern YYSTYPE {}lval;", prefix)?;
    writeln!(w, "extern int {}char;", prefix)?;
    writeln!(w, "extern int {}nerrs;", prefix)?;
    writeln!(w)?;

    // Function declarations
    writeln!(w, "/* Function declarations */")?;
    writeln!(w, "int {}lex(void);", prefix)?;
    writeln!(w, "void {}error(const char *s);", prefix)?;
    writeln!(w)?;

    // Parser tables
    generate_tables(&mut w, grammar, lalr, opts)?;

    // Parser implementation
    generate_parser(&mut w, grammar, lalr, opts)?;

    // Epilogue code
    if let Some(ref epilogue) = grammar.epilogue {
        if !opts.omit_line_directives {
            writeln!(w, "#line {} \"{}\"", epilogue.line, opts.grammar_file)?;
        }
        writeln!(w, "{}", epilogue.code)?;
    }

    w.flush()
        .map_err(|e| YaccError::Io(format!("error writing '{}': {}", path, e)))?;

    Ok(())
}

/// Generate token #define statements
fn generate_token_defines<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    opts: &Options,
) -> Result<(), YaccError> {
    writeln!(w, "/* Token definitions */")?;

    // Collect tokens that need #define (exclude char literals and special tokens)
    let mut tokens: Vec<(String, i32)> = Vec::new();

    for (id, sym) in grammar.symbols.iter().enumerate() {
        if sym.is_terminal && id != EOF_SYMBOL && id != ERROR_SYMBOL {
            if let Some(num) = sym.token_number {
                // Skip character literals (they don't need defines)
                if !sym.name.starts_with('\'') {
                    // Check if name is a valid C identifier
                    if is_valid_c_identifier(&sym.name) {
                        tokens.push((sym.name.clone(), num));
                    }
                }
            }
        }
    }

    // Sort by token number for consistent output
    tokens.sort_by_key(|(_, n)| *n);

    for (name, num) in &tokens {
        let prefixed_name = if opts.sym_prefix != "yy" {
            format!("{}_{}", opts.sym_prefix.to_uppercase(), name)
        } else {
            name.clone()
        };
        writeln!(w, "#define {} {}", prefixed_name, num)?;
    }

    Ok(())
}

/// Check if a name is a valid C identifier
fn is_valid_c_identifier(name: &str) -> bool {
    let mut chars = name.chars();
    match chars.next() {
        Some(c) if c.is_alphabetic() || c == '_' => {}
        _ => return false,
    }
    chars.all(|c| c.is_alphanumeric() || c == '_')
}

/// Generate parsing tables
fn generate_tables<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    lalr: &LALRAutomaton,
    opts: &Options,
) -> Result<(), YaccError> {
    let prefix = &opts.sym_prefix;
    let num_states = lalr.lr0.states.len();

    writeln!(w, "/* Parser tables */")?;
    writeln!(w)?;

    // YYFINAL - the accepting state
    let final_state = find_final_state(lalr);
    writeln!(w, "#define YYFINAL {}", final_state)?;
    writeln!(w)?;

    // YYNTOKENS - number of terminals
    writeln!(w, "#define YYNTOKENS {}", grammar.num_terminals)?;
    writeln!(w)?;

    // YYNNTS - number of non-terminals
    writeln!(w, "#define YYNNTS {}", grammar.num_nonterminals)?;
    writeln!(w)?;

    // YYNRULES - number of rules
    writeln!(w, "#define YYNRULES {}", grammar.productions.len())?;
    writeln!(w)?;

    // YYNSTATES - number of states
    writeln!(w, "#define YYNSTATES {}", num_states)?;
    writeln!(w)?;

    // YYTABLE_NINF - sentinel value for explicit error actions (%nonassoc conflicts)
    writeln!(w, "#define YYTABLE_NINF (-32768)")?;
    writeln!(w)?;

    // Token translation table
    generate_token_translate_table(w, grammar, prefix)?;

    // Rule info tables
    generate_rule_tables(w, grammar, prefix)?;

    // ACTION and GOTO tables in compressed format
    generate_action_goto_tables(w, grammar, lalr, prefix, opts.strict_mode)?;

    // Debug tables (only when debug is enabled)
    if opts.debug_enabled {
        generate_debug_tables(w, grammar, prefix)?;
    }

    Ok(())
}

/// Find the accepting state
fn find_final_state(lalr: &LALRAutomaton) -> usize {
    // The accepting state is where we accept on EOF
    for (state_id, actions) in lalr.action_table.iter().enumerate() {
        if let Some(Action::Accept) = actions.get(&EOF_SYMBOL) {
            return state_id;
        }
    }
    1 // Default fallback
}

/// Generate token translation table
fn generate_token_translate_table<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    prefix: &str,
) -> Result<(), YaccError> {
    // Find max token number to determine table size
    let max_token = grammar
        .symbols
        .iter()
        .filter_map(|s| s.token_number)
        .max()
        .unwrap_or(256);

    writeln!(w, "/* Token number translation table */")?;
    writeln!(w, "static const unsigned short {}translate[] =", prefix)?;
    writeln!(w, "{{")?;

    // Create translation: external token number -> internal symbol ID
    // Use u16 to support grammars with > 255 symbols.
    // Unknown tokens map to ERROR_SYMBOL (1), the error token
    let mut translate = vec![ERROR_SYMBOL as u16; (max_token + 1) as usize];
    translate[0] = 0; // EOF

    for (id, sym) in grammar.symbols.iter().enumerate() {
        if sym.is_terminal {
            if let Some(num) = sym.token_number {
                if num >= 0 && (num as usize) < translate.len() {
                    translate[num as usize] = id as u16;
                }
            }
        }
    }

    // Write table in rows of 16
    for (i, chunk) in translate.chunks(16).enumerate() {
        write!(w, "    ")?;
        for (j, &val) in chunk.iter().enumerate() {
            if i * 16 + j > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:3}", val)?;
        }
        writeln!(w)?;
    }

    writeln!(w, "}};")?;
    writeln!(w)?;

    Ok(())
}

/// Generate rule info tables
fn generate_rule_tables<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    prefix: &str,
) -> Result<(), YaccError> {
    // Build mapping from raw symbol ID to internal symbol number
    // Non-terminals should be numbered starting at num_terminals (YYNTOKENS)
    // so that the parser can compute: nt_idx = yylhs - YYNTOKENS
    let mut symbol_to_internal: std::collections::HashMap<usize, usize> =
        std::collections::HashMap::new();
    for (nt_idx, nt_id) in grammar.nonterminals().enumerate() {
        symbol_to_internal.insert(nt_id, grammar.num_terminals + nt_idx);
    }

    // yyr1 - LHS symbol of each rule (using internal symbol numbers)
    writeln!(w, "/* LHS symbol of each rule */")?;
    writeln!(w, "static const unsigned short {}r1[] =", prefix)?;
    writeln!(w, "{{")?;
    write!(w, "    ")?;
    for (i, prod) in grammar.productions.iter().enumerate() {
        if i > 0 {
            write!(w, ",")?;
        }
        // Convert raw symbol ID to internal symbol number
        let internal_sym = symbol_to_internal
            .get(&prod.lhs)
            .copied()
            .unwrap_or(prod.lhs);
        write!(w, "{:3}", internal_sym)?;
    }
    writeln!(w)?;
    writeln!(w, "}};")?;
    writeln!(w)?;

    // yyr2 - Number of symbols on RHS of each rule
    writeln!(w, "/* Number of symbols on RHS of each rule */")?;
    writeln!(w, "static const unsigned char {}r2[] =", prefix)?;
    writeln!(w, "{{")?;
    write!(w, "    ")?;
    for (i, prod) in grammar.productions.iter().enumerate() {
        if i > 0 {
            write!(w, ",")?;
        }
        write!(w, "{:3}", prod.rhs.len())?;
    }
    writeln!(w)?;
    writeln!(w, "}};")?;
    writeln!(w)?;

    Ok(())
}

/// Generate ACTION and GOTO tables
fn generate_action_goto_tables<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    lalr: &LALRAutomaton,
    prefix: &str,
    strict_mode: bool,
) -> Result<(), YaccError> {
    // We'll use a simple table format (not compressed for now)
    // yypact - default action for each state
    // yytable - action values
    // yycheck - verification values

    let num_states = lalr.action_table.len();

    // Compute default actions (most common action per state)
    let mut default_action: Vec<i16> = vec![0; num_states];
    for (state_id, actions) in lalr.action_table.iter().enumerate() {
        // Find most common reduce action
        let mut reduce_counts: BTreeMap<i16, usize> = BTreeMap::new();
        for action in actions.values() {
            if let Action::Reduce(prod_id) = action {
                *reduce_counts.entry(-(*prod_id as i16) - 1).or_insert(0) += 1;
            }
        }
        if let Some((&action, _)) = reduce_counts.iter().max_by_key(|(_, &count)| count) {
            default_action[state_id] = action;
        }
    }

    // Build packed tables
    let packed = build_packed_tables(grammar, lalr, &default_action, strict_mode);

    // Formal verification: ensure packed tables match canonical tables exactly
    // This runs on every invocation and panics on any mismatch (internal bug)
    crate::verify::verify_tables(grammar, lalr, &packed);

    // yypact - index into yytable for each state's actions
    writeln!(w, "/* Index into yytable for actions */")?;
    writeln!(w, "static const int {}pact[] =", prefix)?;
    writeln!(w, "{{")?;
    for chunk in packed.pact.chunks(10) {
        write!(w, "    ")?;
        for (i, &val) in chunk.iter().enumerate() {
            if i > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:5}", val)?;
        }
        writeln!(w, ",")?;
    }
    writeln!(w, "}};")?;
    writeln!(w)?;

    // yydefact - default reduction for each state
    writeln!(w, "/* Default reduction for each state */")?;
    writeln!(w, "static const unsigned short {}defact[] =", prefix)?;
    writeln!(w, "{{")?;
    for chunk in packed.defact.chunks(10) {
        write!(w, "    ")?;
        for (i, &val) in chunk.iter().enumerate() {
            if i > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:3}", val)?;
        }
        writeln!(w, ",")?;
    }
    writeln!(w, "}};")?;
    writeln!(w)?;

    // yyconsistent - per POSIX: states where only reduce by single rule exists
    // Parser can skip yylex() in these states
    writeln!(
        w,
        "/* Consistent states (skip lookahead) - POSIX optimization */"
    )?;
    writeln!(w, "static const unsigned char {}consistent[] =", prefix)?;
    writeln!(w, "{{")?;
    for chunk in packed.consistent.chunks(10) {
        write!(w, "    ")?;
        for (i, &val) in chunk.iter().enumerate() {
            if i > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:3}", if val { 1 } else { 0 })?;
        }
        writeln!(w, ",")?;
    }
    writeln!(w, "}};")?;
    writeln!(w)?;

    // yypgoto - index into yytable for goto
    writeln!(w, "/* Index into yytable for goto */")?;
    writeln!(w, "static const int {}pgoto[] =", prefix)?;
    writeln!(w, "{{")?;
    for chunk in packed.pgoto.chunks(10) {
        write!(w, "    ")?;
        for (i, &val) in chunk.iter().enumerate() {
            if i > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:5}", val)?;
        }
        writeln!(w, ",")?;
    }
    writeln!(w, "}};")?;
    writeln!(w)?;

    // yydefgoto - default goto for each non-terminal
    writeln!(w, "/* Default goto for each non-terminal */")?;
    writeln!(w, "static const short {}defgoto[] =", prefix)?;
    writeln!(w, "{{")?;
    for chunk in packed.defgoto.chunks(10) {
        write!(w, "    ")?;
        for (i, &val) in chunk.iter().enumerate() {
            if i > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:5}", val)?;
        }
        writeln!(w, ",")?;
    }
    writeln!(w, "}};")?;
    writeln!(w)?;

    // yytable - packed action/goto values
    writeln!(w, "/* Packed action/goto values */")?;
    writeln!(w, "static const short {}table[] =", prefix)?;
    writeln!(w, "{{")?;
    for chunk in packed.table.chunks(10) {
        write!(w, "    ")?;
        for (i, &val) in chunk.iter().enumerate() {
            if i > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:5}", val)?;
        }
        writeln!(w, ",")?;
    }
    writeln!(w, "}};")?;
    writeln!(w)?;

    // yycheck - verification for packed values
    writeln!(w, "/* Verification for packed values */")?;
    writeln!(w, "static const short {}check[] =", prefix)?;
    writeln!(w, "{{")?;
    for chunk in packed.check.chunks(10) {
        write!(w, "    ")?;
        for (i, &val) in chunk.iter().enumerate() {
            if i > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:5}", val)?;
        }
        writeln!(w, ",")?;
    }
    writeln!(w, "}};")?;
    writeln!(w)?;

    Ok(())
}

/// Build packed tables (simplified version)
fn build_packed_tables(
    grammar: &Grammar,
    lalr: &LALRAutomaton,
    _default_action: &[i16],
    strict_mode: bool,
) -> PackedTables {
    let num_states = lalr.action_table.len();
    let num_nonterminals = grammar.num_nonterminals;

    // Find max terminal symbol ID to determine action slot size per state
    // Symbol IDs may not be contiguous (e.g., $end=0, error=1, $accept=2 (NT), NUM=3)
    let max_terminal_id = grammar
        .symbols
        .iter()
        .enumerate()
        .filter(|(_, s)| s.is_terminal)
        .map(|(id, _)| id)
        .max()
        .unwrap_or(0)
        + 1; // +1 because we need slots 0..max_id inclusive

    // For simplicity, we'll use a direct table format
    // A more sophisticated implementation would use row displacement

    // Action table uses max_terminal_id slots per state (not num_terminals)
    // because symbol IDs are used directly as indices
    let action_table_size = num_states * max_terminal_id;
    let goto_table_size = num_nonterminals * num_states;
    let table_size = action_table_size + goto_table_size;
    let mut table = vec![0i16; table_size.max(1)];
    let mut check = vec![-1i16; table_size.max(1)];

    let mut pact = vec![0i32; num_states];
    let mut defact = vec![0u16; num_states];
    let mut pgoto = vec![0i32; num_nonterminals.max(1)];
    let mut defgoto = vec![-1i16; num_nonterminals.max(1)];
    // Per POSIX: track states where only one reduce action exists (no shifts)
    // so the parser can skip calling yylex() in those states
    // In strict mode, disable this optimization to preserve exact yylex timing
    let mut consistent = vec![false; num_states];

    // Fill action table
    for (state_id, actions) in lalr.action_table.iter().enumerate() {
        pact[state_id] = (state_id * max_terminal_id) as i32;

        // Find default reduction and check if state is "consistent"
        // A state is consistent if:
        // - It has no shift actions (only reduces and/or error)
        // - All reduce actions reduce by the same rule
        let mut best_reduce: Option<usize> = None;
        let mut best_count = 0;
        let mut has_shift = false;
        let mut all_same_reduce = true;
        let mut first_reduce: Option<usize> = None;

        for action in actions.values() {
            match action {
                Action::Shift(_) | Action::Accept => {
                    has_shift = true;
                }
                Action::Reduce(prod_id) => {
                    let count = actions
                        .values()
                        .filter(|a| matches!(a, Action::Reduce(p) if p == prod_id))
                        .count();
                    if count > best_count {
                        best_count = count;
                        best_reduce = Some(*prod_id);
                    }
                    // Check if all reduces are by the same rule
                    match first_reduce {
                        None => first_reduce = Some(*prod_id),
                        Some(first) if first != *prod_id => all_same_reduce = false,
                        _ => {}
                    }
                }
                Action::Error => {}
            }
        }

        // Store production_id + 1 so that 0 means "no default action"
        defact[state_id] = match best_reduce {
            Some(prod_id) => (prod_id + 1) as u16,
            None => 0,
        };

        // State is consistent if no shifts and all reduces are by same rule
        // In strict mode, disable this optimization to preserve exact yylex timing
        if !strict_mode {
            consistent[state_id] = !has_shift && all_same_reduce && best_reduce.is_some();
        }

        for (&symbol, action) in actions {
            if grammar.is_terminal(symbol) {
                let idx = state_id * max_terminal_id + symbol;
                if idx < table.len() {
                    table[idx] = action_to_value(action);
                    check[idx] = symbol as i16;
                }
            }
        }
    }

    // Fill goto table (starts after action table)
    for (nt_idx, nt_id) in grammar.nonterminals().enumerate() {
        if nt_idx < pgoto.len() {
            pgoto[nt_idx] = (action_table_size + nt_idx * num_states) as i32;
        }

        // Find default goto
        let mut goto_counts: BTreeMap<i16, usize> = BTreeMap::new();
        for (state_id, gotos) in lalr.goto_table.iter().enumerate() {
            if let Some(&target) = gotos.get(&nt_id) {
                *goto_counts.entry(target as i16).or_insert(0) += 1;

                let idx = action_table_size + nt_idx * num_states + state_id;
                if idx < table.len() {
                    table[idx] = target as i16;
                    check[idx] = state_id as i16;
                }
            }
        }

        if let Some((&target, _)) = goto_counts.iter().max_by_key(|(_, &count)| count) {
            if nt_idx < defgoto.len() {
                defgoto[nt_idx] = target;
            }
        }
    }

    PackedTables {
        table,
        check,
        pact,
        pgoto,
        defact,
        defgoto,
        consistent,
        num_states,
    }
}

/// Convert action to table value
fn action_to_value(action: &Action) -> i16 {
    match action {
        Action::Shift(state) => *state as i16,
        Action::Reduce(prod) => -((*prod as i16) + 1),
        Action::Accept => 0,
        Action::Error => i16::MIN,
    }
}

/// Generate debugging tables (token names and rule descriptions)
fn generate_debug_tables<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    prefix: &str,
) -> Result<(), YaccError> {
    writeln!(w, "#if YYDEBUG")?;
    writeln!(w)?;

    // Token name table - maps internal symbol ID to printable name
    writeln!(w, "/* Symbol names for debugging */")?;
    writeln!(w, "static const char *const {}tname[] =", prefix)?;
    writeln!(w, "{{")?;

    for (id, sym) in grammar.symbols.iter().enumerate() {
        let name = &sym.name;
        // Escape special characters in name for C string
        let escaped = escape_c_string(name);
        if id > 0 {
            writeln!(w, ",")?;
        }
        write!(w, "    \"{}\"", escaped)?;
    }
    writeln!(w)?;
    writeln!(w, "}};")?;
    writeln!(w)?;

    // Rule descriptions - human-readable form of each rule
    writeln!(w, "/* Rule descriptions for debugging */")?;
    writeln!(w, "static const char *const {}rule[] =", prefix)?;
    writeln!(w, "{{")?;

    for (id, prod) in grammar.productions.iter().enumerate() {
        let lhs_name = grammar.symbol_name(prod.lhs);
        let mut rhs_str = String::new();
        for &sym_id in &prod.rhs {
            if !rhs_str.is_empty() {
                rhs_str.push(' ');
            }
            rhs_str.push_str(grammar.symbol_name(sym_id));
        }
        if rhs_str.is_empty() {
            rhs_str = "/* empty */".to_string();
        }

        let rule_str = format!("{} -> {}", lhs_name, rhs_str);
        let escaped = escape_c_string(&rule_str);

        if id > 0 {
            writeln!(w, ",")?;
        }
        write!(w, "    \"{}\"", escaped)?;
    }
    writeln!(w)?;
    writeln!(w, "}};")?;
    writeln!(w)?;

    writeln!(w, "#endif /* YYDEBUG */")?;
    writeln!(w)?;

    Ok(())
}

/// Get the translate table size (max token number + 1)
fn get_translate_table_size(grammar: &Grammar) -> usize {
    let max_token = grammar
        .symbols
        .iter()
        .filter_map(|s| s.token_number)
        .max()
        .unwrap_or(256);
    (max_token + 1) as usize
}

/// Escape a string for use in a C string literal
fn escape_c_string(s: &str) -> String {
    let mut result = String::new();
    for c in s.chars() {
        match c {
            '\\' => result.push_str("\\\\"),
            '"' => result.push_str("\\\""),
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            c if c.is_ascii_control() => {
                result.push_str(&format!("\\{:03o}", c as u8));
            }
            c => result.push(c),
        }
    }
    result
}

/// Generate parser implementation
fn generate_parser<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    _lalr: &LALRAutomaton,
    opts: &Options,
) -> Result<(), YaccError> {
    let prefix = &opts.sym_prefix;

    writeln!(w, "/* Parser implementation */")?;
    writeln!(w)?;

    // Global variables
    writeln!(w, "YYSTYPE {}lval;", prefix)?;
    writeln!(w, "int {}char;", prefix)?;
    writeln!(w, "int {}nerrs;", prefix)?;
    writeln!(w)?;

    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "int {}debug = 0;", prefix)?;
        writeln!(w, "#endif")?;
        writeln!(w)?;
    }

    // Stack size
    writeln!(
        w,
        r#"#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif
"#
    )?;

    // Error handling macros (POSIX required)
    writeln!(
        w,
        "/* YYERROR - trigger error handling from semantic action */"
    )?;
    writeln!(w, "#define YYERROR goto {}errlab1", prefix)?;
    writeln!(w)?;
    writeln!(w, "/* YYACCEPT - return successfully from yyparse */")?;
    writeln!(w, "#define YYACCEPT goto {}acceptlab", prefix)?;
    writeln!(w)?;
    writeln!(w, "/* YYABORT - return with failure from yyparse */")?;
    writeln!(w, "#define YYABORT goto {}abortlab", prefix)?;
    writeln!(w)?;
    writeln!(w, "/* yyerrok - signal that error recovery is complete */")?;
    writeln!(w, "#define yyerrok ({}errflag = 0)", prefix)?;
    writeln!(w)?;
    writeln!(w, "/* yyclearin - discard lookahead token */")?;
    writeln!(w, "#define yyclearin ({}char = -1)", prefix)?;
    writeln!(w)?;
    writeln!(
        w,
        "/* YYRECOVERING - nonzero if recovering from syntax error */"
    )?;
    writeln!(w, "#define YYRECOVERING() ({}errflag != 0)", prefix)?;
    writeln!(w)?;

    // yyparse function
    writeln!(w, "int")?;
    writeln!(w, "{}parse(void)", prefix)?;
    writeln!(w, "{{")?;

    // Local variables
    writeln!(w, "    int {}state;", prefix)?;
    writeln!(w, "    int {}n;", prefix)?;
    writeln!(w, "    int {}result;", prefix)?;
    writeln!(
        w,
        "    int {}errflag = 0;  /* error recovery counter: 0=none, 1-3=recovering */",
        prefix
    )?;
    writeln!(w)?;

    // Stacks
    writeln!(w, "    /* State stack */")?;
    writeln!(w, "    int {}ssp_offset;", prefix)?;
    writeln!(w, "    int *{}ss = NULL;", prefix)?;
    writeln!(w, "    int *{}sslim;", prefix)?;
    writeln!(w, "    int {}stacksize = YYINITDEPTH;", prefix)?;
    writeln!(w)?;

    writeln!(w, "    /* Value stack */")?;
    writeln!(w, "    YYSTYPE *{}vs = NULL;", prefix)?;
    writeln!(w, "    YYSTYPE *{}vsp;", prefix)?;
    writeln!(w, "    YYSTYPE {}val = {{0}};", prefix)?;
    writeln!(w)?;

    // Allocate stacks
    writeln!(
        w,
        "    {}ss = (int *) malloc({}stacksize * sizeof(int));",
        prefix, prefix
    )?;
    writeln!(
        w,
        "    {}vs = (YYSTYPE *) malloc({}stacksize * sizeof(YYSTYPE));",
        prefix, prefix
    )?;
    writeln!(
        w,
        "    if (!{}ss || !{}vs) goto {}exhausted;",
        prefix, prefix, prefix
    )?;
    writeln!(w)?;

    writeln!(w, "    {}ssp_offset = 0;", prefix)?;
    writeln!(w, "    {}vsp = {}vs;", prefix, prefix)?;
    writeln!(
        w,
        "    {}sslim = {}ss + {}stacksize - 1;",
        prefix, prefix, prefix
    )?;
    writeln!(w)?;

    // Initialize
    writeln!(w, "    {}state = 0;", prefix)?;
    writeln!(w, "    {}char = -1;", prefix)?;
    writeln!(w, "    {}nerrs = 0;", prefix)?;
    writeln!(w)?;

    writeln!(w, "{}newstate:", prefix)?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "    if ({}debug)", prefix)?;
        writeln!(
            w,
            "        fprintf(stderr, \"Entering state %d\\n\", {}state);",
            prefix
        )?;
        writeln!(w, "#endif")?;
    }
    writeln!(
        w,
        "    {}ss[{}ssp_offset] = {}state;",
        prefix, prefix, prefix
    )?;
    writeln!(w)?;

    // Check for stack overflow
    writeln!(
        w,
        "    if ({}ss + {}ssp_offset >= {}sslim) {{",
        prefix, prefix, prefix
    )?;
    writeln!(w, "        int new_size = {}stacksize * 2;", prefix)?;
    writeln!(
        w,
        "        if (new_size > YYMAXDEPTH) new_size = YYMAXDEPTH;"
    )?;
    writeln!(
        w,
        "        if (new_size <= {}stacksize) goto {}exhausted;",
        prefix, prefix
    )?;
    writeln!(
        w,
        "        {}ss = (int *) realloc({}ss, new_size * sizeof(int));",
        prefix, prefix
    )?;
    writeln!(
        w,
        "        {}vs = (YYSTYPE *) realloc({}vs, new_size * sizeof(YYSTYPE));",
        prefix, prefix
    )?;
    writeln!(
        w,
        "        if (!{}ss || !{}vs) goto {}exhausted;",
        prefix, prefix, prefix
    )?;
    writeln!(
        w,
        "        {}vsp = {}vs + {}ssp_offset;",
        prefix, prefix, prefix
    )?;
    writeln!(w, "        {}sslim = {}ss + new_size - 1;", prefix, prefix)?;
    writeln!(w, "        {}stacksize = new_size;", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // POSIX optimization: In consistent states (only one reduce action),
    // skip token read and go directly to reduce
    writeln!(w, "    /* POSIX: skip lookahead in consistent states */")?;
    writeln!(
        w,
        "    if ({}consistent[{}state] && {}defact[{}state]) {{",
        prefix, prefix, prefix, prefix
    )?;
    writeln!(
        w,
        "        {}n = {}defact[{}state] - 1;",
        prefix, prefix, prefix
    )?;
    writeln!(w, "        goto {}reduce;", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Get next token if needed
    writeln!(w, "    if ({}char < 0) {{", prefix)?;
    writeln!(w, "        {}char = {}lex();", prefix, prefix)?;
    writeln!(w, "        if ({}char < 0) {}char = 0;", prefix, prefix)?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "        if ({}debug) {{", prefix)?;
        writeln!(
            w,
            "            int {}tok = {}char < {} ? {}translate[{}char] : {};",
            prefix,
            prefix,
            get_translate_table_size(grammar),
            prefix,
            prefix,
            ERROR_SYMBOL
        )?;
        writeln!(
            w,
            "            fprintf(stderr, \"Reading token %s (%d)\\n\", {}tname[{}tok], {}char);",
            prefix, prefix, prefix
        )?;
        writeln!(w, "        }}")?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Check for acceptance: in final state with $end lookahead
    writeln!(
        w,
        "    if ({}state == YYFINAL && {}char == 0)",
        prefix, prefix
    )?;
    writeln!(w, "        goto {}acceptlab;", prefix)?;
    writeln!(w)?;

    // Lookup action
    writeln!(w, "    {}n = {}pact[{}state];", prefix, prefix, prefix)?;
    // Note: We don't check for yyn == 0 as a sentinel because 0 is a valid offset.
    // Instead, the yycheck comparison below handles invalid lookups.
    writeln!(w)?;
    writeln!(
        w,
        "    {}n += {}char < {} ? {}translate[{}char] : {};",
        prefix,
        prefix,
        get_translate_table_size(grammar),
        prefix,
        prefix,
        ERROR_SYMBOL
    )?;
    writeln!(w, "    if ({}n < 0 || {}n >= (int)(sizeof({}table)/sizeof({}table[0])) || {}check[{}n] != ({}char < {} ? {}translate[{}char] : {}))",
        prefix, prefix, prefix, prefix, prefix, prefix, prefix, get_translate_table_size(grammar), prefix, prefix, ERROR_SYMBOL)?;
    writeln!(w, "        goto {}default_action;", prefix)?;
    writeln!(w)?;
    writeln!(w, "    {}n = {}table[{}n];", prefix, prefix, prefix)?;
    writeln!(w)?;

    // Handle action
    writeln!(w, "    if ({}n > 0) {{", prefix)?;
    writeln!(w, "        /* Shift */")?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "        if ({}debug) {{", prefix)?;
        writeln!(
            w,
            "            int {}tok = {}char < {} ? {}translate[{}char] : {};",
            prefix,
            prefix,
            get_translate_table_size(grammar),
            prefix,
            prefix,
            ERROR_SYMBOL
        )?;
        writeln!(
            w,
            "            fprintf(stderr, \"Shifting token %s (%d), entering state %d\\n\",",
        )?;
        writeln!(
            w,
            "                    {}tname[{}tok], {}char, {}n);",
            prefix, prefix, prefix, prefix
        )?;
        writeln!(w, "        }}")?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "        {}ssp_offset++;", prefix)?;
    writeln!(w, "        {}vsp++;", prefix)?;
    writeln!(w, "        *{}vsp = {}lval;", prefix, prefix)?;
    writeln!(w, "        {}state = {}n;", prefix, prefix)?;
    writeln!(w, "        {}char = -1;", prefix)?;
    writeln!(w, "        if ({}errflag > 0) {}errflag--;", prefix, prefix)?;
    writeln!(w, "        goto {}newstate;", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Check for error: 0 = no action, YYTABLE_NINF = explicit error (%nonassoc conflict)
    writeln!(
        w,
        "    if ({}n == 0 || {}n == YYTABLE_NINF) goto {}errlab;",
        prefix, prefix, prefix
    )?;
    writeln!(w)?;

    writeln!(w, "    /* Reduce */")?;
    // Decode production number: table stores -(prod + 1), so prod = -n - 1
    writeln!(w, "    {}n = -{}n - 1;", prefix, prefix)?;
    writeln!(w, "    goto {}reduce;", prefix)?;
    writeln!(w)?;

    // Default action
    writeln!(w, "{}default_action:", prefix)?;
    // defact stores production_id + 1, so 0 means no default action
    writeln!(w, "    {}n = {}defact[{}state];", prefix, prefix, prefix)?;
    writeln!(w, "    if ({}n == 0) goto {}errlab;", prefix, prefix)?;
    writeln!(w, "    {}n--;  /* defact stores prod+1 */", prefix)?;
    writeln!(w)?;

    // Reduce
    writeln!(w, "{}reduce:", prefix)?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "    if ({}debug)", prefix)?;
        writeln!(
            w,
            "        fprintf(stderr, \"Reducing by rule %d (%s)\\n\", {}n, {}rule[{}n]);",
            prefix, prefix, prefix
        )?;
        writeln!(w, "#endif")?;
    }

    // Switch on rule number for semantic actions
    writeln!(w, "    switch ({}n) {{", prefix)?;

    for (prod_id, prod) in grammar.productions.iter().enumerate() {
        // Generate case for:
        // - Productions with explicit actions
        // - Productions with empty RHS (no default value)
        // - Productions without actions but with non-empty RHS (POSIX: $$ = $1 default)
        if prod.action.is_some() || !prod.rhs.is_empty() {
            writeln!(w, "    case {}:", prod_id)?;
            writeln!(w, "        {{")?;

            if let Some(ref action) = prod.action {
                // Transform $$ and $n references
                let has_union = grammar.union_def.is_some();
                let transformed =
                    transform_action(action, prod.rhs.len(), grammar, prod, prefix, has_union);
                if !opts.omit_line_directives {
                    writeln!(w, "#line {} \"{}\"", prod.line, opts.grammar_file)?;
                }
                writeln!(w, "        {}", transformed)?;
            } else if !prod.rhs.is_empty() {
                // POSIX: "By default, the value of a rule shall be the value
                // of the first element in it." - implicitly emit $$ = $1
                let rhs_len = prod.rhs.len();
                writeln!(
                    w,
                    "        {}val = {}vsp[{}];  /* $$ = $1 (default) */",
                    prefix,
                    prefix,
                    1 - rhs_len as i32
                )?;
            }

            writeln!(w, "        }}")?;
            writeln!(w, "        break;")?;
        }
    }

    writeln!(w, "    default:")?;
    writeln!(w, "        break;")?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Pop stack and push result
    writeln!(w, "    {}ssp_offset -= {}r2[{}n];", prefix, prefix, prefix)?;
    writeln!(w, "    {}vsp -= {}r2[{}n];", prefix, prefix, prefix)?;
    writeln!(w, "    {}vsp++;", prefix)?;
    writeln!(w, "    *{}vsp = {}val;", prefix, prefix)?;
    writeln!(w)?;

    // Goto
    writeln!(w, "    {{",)?;
    writeln!(w, "        int {}lhs = {}r1[{}n];", prefix, prefix, prefix)?;
    writeln!(w, "        int {}idx = {}lhs - YYNTOKENS;", prefix, prefix)?;
    writeln!(
        w,
        "        int {}gidx = {}pgoto[{}idx] + {}ss[{}ssp_offset];",
        prefix, prefix, prefix, prefix, prefix
    )?;
    writeln!(w, "        if ({}gidx >= 0 && {}gidx < (int)(sizeof({}table)/sizeof({}table[0])) && {}check[{}gidx] == {}ss[{}ssp_offset])",
        prefix, prefix, prefix, prefix, prefix, prefix, prefix, prefix)?;
    writeln!(
        w,
        "            {}state = {}table[{}gidx];",
        prefix, prefix, prefix
    )?;
    writeln!(w, "        else")?;
    writeln!(
        w,
        "            {}state = {}defgoto[{}idx];",
        prefix, prefix, prefix
    )?;
    writeln!(w, "    }}")?;
    writeln!(w, "    {}ssp_offset++;", prefix)?;
    writeln!(w, "    goto {}newstate;", prefix)?;
    writeln!(w)?;

    // Error handling - POSIX compliant algorithm
    // errlab: called when parser detects a syntax error
    writeln!(w, "{}errlab:", prefix)?;
    writeln!(w, "    /* Error detected by parser */")?;
    writeln!(w, "    if ({}errflag == 0) {{", prefix)?;
    writeln!(
        w,
        "        /* First error, or recovered from previous error */"
    )?;
    writeln!(w, "        {}nerrs++;", prefix)?;
    writeln!(w, "        {}error(\"syntax error\");", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w, "    goto {}errlab1;", prefix)?;
    writeln!(w)?;

    // errlab1: YYERROR jumps here (doesn't call yyerror per POSIX)
    writeln!(w, "{}errlab1:", prefix)?;
    writeln!(w, "    if ({}errflag == 3) {{", prefix)?;
    writeln!(
        w,
        "        /* Still trying to recover, discard lookahead */"
    )?;
    writeln!(
        w,
        "        if ({}char == 0) goto {}abortlab;  /* EOF, can't recover */",
        prefix, prefix
    )?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "        if ({}debug) {{", prefix)?;
        writeln!(
            w,
            "            int {}tok = {}char < {} ? {}translate[{}char] : {};",
            prefix,
            prefix,
            get_translate_table_size(grammar),
            prefix,
            prefix,
            ERROR_SYMBOL
        )?;
        writeln!(
            w,
            "            fprintf(stderr, \"Error recovery: discarding token %s (%d)\\n\", {}tname[{}tok], {}char);",
            prefix, prefix, prefix
        )?;
        writeln!(w, "        }}")?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "        {}char = -1;", prefix)?;
    writeln!(w, "        goto {}newstate;", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Error recovery: pop until we can shift error token
    writeln!(w, "    /* Pop stack until we can shift the error token */")?;
    writeln!(w, "    {}errflag = 3;", prefix)?;
    writeln!(w, "    for (;;) {{")?;
    writeln!(w, "        {}n = {}pact[{}state];", prefix, prefix, prefix)?;
    writeln!(w, "        if ({}n != 0) {{", prefix)?;
    writeln!(
        w,
        "            {}n += {};  /* error token */",
        prefix, ERROR_SYMBOL
    )?;
    writeln!(w, "            if ({}n >= 0 && {}n < (int)(sizeof({}table)/sizeof({}table[0])) && {}check[{}n] == {}) {{",
        prefix, prefix, prefix, prefix, prefix, prefix, ERROR_SYMBOL)?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "                if ({}debug)", prefix)?;
        writeln!(w, "                    fprintf(stderr, \"Shifting error token, entering state %d\\n\", {}table[{}n]);", prefix, prefix)?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "                /* Shift the error token */")?;
    writeln!(w, "                {}ssp_offset++;", prefix)?;
    writeln!(w, "                {}vsp++;", prefix)?;
    writeln!(
        w,
        "                {}state = {}table[{}n];",
        prefix, prefix, prefix
    )?;
    writeln!(w, "                goto {}newstate;", prefix)?;
    writeln!(w, "            }}")?;
    writeln!(w, "        }}")?;
    writeln!(
        w,
        "        if ({}ssp_offset <= 0) goto {}abortlab;",
        prefix, prefix
    )?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "        if ({}debug)", prefix)?;
        writeln!(
            w,
            "            fprintf(stderr, \"Error recovery: popping state %d\\n\", {}state);",
            prefix
        )?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "        {}ssp_offset--;", prefix)?;
    writeln!(w, "        {}vsp--;", prefix)?;
    writeln!(
        w,
        "        {}state = {}ss[{}ssp_offset];",
        prefix, prefix, prefix
    )?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Accept
    writeln!(w, "{}acceptlab:", prefix)?;
    writeln!(w, "    {}result = 0;", prefix)?;
    writeln!(w, "    goto {}cleanup;", prefix)?;
    writeln!(w)?;

    // Abort
    writeln!(w, "{}abortlab:", prefix)?;
    writeln!(w, "    {}result = 1;", prefix)?;
    writeln!(w, "    goto {}cleanup;", prefix)?;
    writeln!(w)?;

    // Stack exhausted
    writeln!(w, "{}exhausted:", prefix)?;
    writeln!(w, "    {}error(\"parser stack exhausted\");", prefix)?;
    writeln!(w, "    {}result = 2;", prefix)?;
    writeln!(w)?;

    // Cleanup
    writeln!(w, "{}cleanup:", prefix)?;
    writeln!(w, "    free({}ss);", prefix)?;
    writeln!(w, "    free({}vs);", prefix)?;
    writeln!(w, "    return {}result;", prefix)?;
    writeln!(w, "}}")?;
    writeln!(w)?;

    Ok(())
}

/// Transform semantic action: replace $$ and $n with stack references
///
/// POSIX defines the following pseudo-variables:
/// - `$$` : The value of the action (LHS)
/// - `$number` : Value of component N in the RHS (1-indexed for RHS, 0 or negative for left context)
/// - `$<tag>$` : Like $$ but with explicit type tag
/// - `$<tag>number` : Like $number but with explicit type tag
///
/// For $n where n <= 0:
/// - `$0` refers to the name immediately preceding the leftmost symbol of the current rule
/// - `$-1` refers to the symbol to its left, etc.
///
/// These access values on the parser's stack preceding the current rule.
fn transform_action(
    action: &str,
    rhs_len: usize,
    grammar: &Grammar,
    prod: &crate::grammar::Production,
    prefix: &str,
    has_union: bool,
) -> String {
    let mut result = String::new();
    let mut chars = action.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '$' {
            match chars.peek() {
                Some('$') => {
                    chars.next();
                    // Use LHS type if available
                    if let Some(ref tag) = grammar.symbols[prod.lhs].tag {
                        result.push_str(&format!("({}val.{})", prefix, tag));
                    } else {
                        // P1-3: POSIX allows warning when %union used but type undetermined
                        if has_union {
                            let lhs_name = grammar.symbol_name(prod.lhs);
                            diag::warning(
                                diag::Position::line_only(prod.line as u32),
                                &format!(
                                    "$$ has no declared type; '{}' lacks a %type declaration",
                                    lhs_name
                                ),
                            );
                        }
                        result.push_str(&format!("({}val)", prefix));
                    }
                }
                Some('<') => {
                    // $<tag>$ or $<tag>n - explicit type tag
                    chars.next();
                    let mut tag = String::new();
                    while let Some(&tc) = chars.peek() {
                        if tc == '>' {
                            chars.next();
                            break;
                        }
                        tag.push(tc);
                        chars.next();
                    }
                    // Now check what follows the tag
                    match chars.peek() {
                        Some('$') => {
                            chars.next();
                            result.push_str(&format!("({}val.{})", prefix, tag));
                        }
                        Some(&c) if c.is_ascii_digit() || c == '-' => {
                            // Parse the number (can be negative)
                            let mut num_str = String::new();
                            if c == '-' {
                                num_str.push('-');
                                chars.next();
                            }
                            while let Some(&d) = chars.peek() {
                                if d.is_ascii_digit() {
                                    num_str.push(d);
                                    chars.next();
                                } else {
                                    break;
                                }
                            }
                            let n: i32 = num_str.parse().unwrap_or(0);
                            // Generate stack reference with explicit tag
                            let stack_ref =
                                generate_stack_reference(n, rhs_len, Some(&tag), prefix);
                            result.push_str(&stack_ref);
                        }
                        _ => {
                            // Invalid syntax, pass through
                            result.push_str("$<");
                            result.push_str(&tag);
                            result.push('>');
                        }
                    }
                }
                Some(&c) if c.is_ascii_digit() || c == '-' => {
                    // $n or $-n - reference to stack value
                    let mut num_str = String::new();
                    if c == '-' {
                        num_str.push('-');
                        chars.next();
                    }
                    while let Some(&d) = chars.peek() {
                        if d.is_ascii_digit() {
                            num_str.push(d);
                            chars.next();
                        } else {
                            break;
                        }
                    }
                    let n: i32 = num_str.parse().unwrap_or(0);

                    // Try to determine type from RHS symbol (only for positive indices within RHS)
                    let (sym_tag, sym_name) = if n > 0 && (n as usize) <= rhs_len {
                        let sym_id = prod.rhs[n as usize - 1];
                        (
                            grammar.symbols[sym_id].tag.clone(),
                            Some(grammar.symbol_name(sym_id).to_string()),
                        )
                    } else {
                        // For $0, $-1, etc., no automatic type inference
                        (None, None)
                    };

                    // P1-3: POSIX allows warning when %union used but type undetermined
                    if has_union && sym_tag.is_none() && n > 0 && (n as usize) <= rhs_len {
                        if let Some(ref name) = sym_name {
                            diag::warning(
                                diag::Position::line_only(prod.line as u32),
                                &format!(
                                    "${} has no declared type; '{}' lacks a %type declaration",
                                    n, name
                                ),
                            );
                        }
                    }

                    let stack_ref =
                        generate_stack_reference(n, rhs_len, sym_tag.as_deref(), prefix);
                    result.push_str(&stack_ref);
                }
                _ => {
                    result.push('$');
                }
            }
        } else {
            result.push(c);
        }
    }

    result
}

/// Generate a stack reference for $n syntax
///
/// For a rule with `rhs_len` symbols on the RHS:
/// - $1 refers to {prefix}vsp[-(rhs_len-1)] (first RHS symbol)
/// - $rhs_len refers to {prefix}vsp[0] (last RHS symbol)
/// - $0 refers to {prefix}vsp[-rhs_len] (symbol before the rule on the stack)
/// - $-1 refers to {prefix}vsp[-(rhs_len+1)] (two symbols before the rule)
///
/// The formula: offset = -(rhs_len - n) = n - rhs_len
fn generate_stack_reference(n: i32, rhs_len: usize, tag: Option<&str>, prefix: &str) -> String {
    // Calculate the stack offset
    // {prefix}vsp points to the top of the value stack (last RHS symbol)
    // For $n: offset from {prefix}vsp = n - rhs_len
    // Examples with rhs_len=3:
    //   $1 -> offset = 1-3 = -2 (first RHS symbol)
    //   $2 -> offset = 2-3 = -1
    //   $3 -> offset = 3-3 = 0 (last RHS symbol, top of stack)
    //   $0 -> offset = 0-3 = -3 (one before the rule)
    //   $-1 -> offset = -1-3 = -4 (two before the rule)
    let offset = n - rhs_len as i32;

    if let Some(tag) = tag {
        if offset == 0 {
            format!("({}vsp[0].{})", prefix, tag)
        } else {
            format!("({}vsp[{}].{})", prefix, offset, tag)
        }
    } else if offset == 0 {
        format!("({}vsp[0])", prefix)
    } else {
        format!("({}vsp[{}])", prefix, offset)
    }
}

/// Generate header file (y.tab.h)
fn generate_header_file(path: &str, opts: &Options, grammar: &Grammar) -> Result<(), YaccError> {
    let file = File::create(path)
        .map_err(|e| YaccError::Io(format!("cannot create '{}': {}", path, e)))?;
    let mut w = BufWriter::new(file);

    writeln!(
        w,
        "/* Header file generated by yacc from posixutils-rs v{} */",
        env!("CARGO_PKG_VERSION")
    )?;
    writeln!(w)?;

    // Token definitions
    generate_token_defines(&mut w, grammar, opts)?;
    writeln!(w)?;

    // YYSTYPE definition
    if let Some(ref union_def) = grammar.union_def {
        writeln!(w, "#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED")?;
        if !opts.omit_line_directives {
            writeln!(w, "#line {} \"{}\"", union_def.line, opts.grammar_file)?;
        }
        writeln!(w, "typedef union YYSTYPE")?;
        writeln!(w, "{}", union_def.code)?;
        writeln!(w, " YYSTYPE;")?;
        writeln!(w, "# define YYSTYPE_IS_DECLARED 1")?;
        writeln!(w, "#endif")?;
    } else {
        writeln!(
            w,
            r#"#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_DECLARED 1
#endif
"#
        )?;
    }

    // External yylval
    writeln!(w, "extern YYSTYPE {}lval;", opts.sym_prefix)?;

    w.flush()
        .map_err(|e| YaccError::Io(format!("error writing '{}': {}", path, e)))?;

    Ok(())
}

/// Generate description file (y.output)
fn generate_description_file(
    path: &str,
    grammar: &Grammar,
    lalr: &LALRAutomaton,
) -> Result<(), YaccError> {
    let file = File::create(path)
        .map_err(|e| YaccError::Io(format!("cannot create '{}': {}", path, e)))?;
    let mut w = BufWriter::new(file);

    writeln!(w, "Grammar")?;
    writeln!(w)?;

    // List rules
    for (i, prod) in grammar.productions.iter().enumerate() {
        write!(w, "  {:3} {}: ", i, grammar.symbol_name(prod.lhs))?;
        if prod.rhs.is_empty() {
            writeln!(w, "/* empty */")?;
        } else {
            for &sym in &prod.rhs {
                write!(w, "{} ", grammar.symbol_name(sym))?;
            }
            writeln!(w)?;
        }
    }
    writeln!(w)?;

    // List terminals
    writeln!(w, "Terminals, with rules where they appear")?;
    writeln!(w)?;
    for (id, sym) in grammar.symbols.iter().enumerate() {
        if sym.is_terminal {
            write!(w, "  {} ({})", sym.name, sym.token_number.unwrap_or(0))?;
            let prods: Vec<usize> = grammar
                .productions
                .iter()
                .enumerate()
                .filter(|(_, p)| p.rhs.contains(&id))
                .map(|(i, _)| i)
                .collect();
            if !prods.is_empty() {
                write!(w, " ")?;
                for (i, p) in prods.iter().enumerate() {
                    if i > 0 {
                        write!(w, " ")?;
                    }
                    write!(w, "{}", p)?;
                }
            }
            writeln!(w)?;
        }
    }
    writeln!(w)?;

    // List non-terminals
    writeln!(w, "Nonterminals, with rules where they appear")?;
    writeln!(w)?;
    for (id, sym) in grammar.symbols.iter().enumerate() {
        if !sym.is_terminal {
            write!(w, "  {}", sym.name)?;
            let lhs_prods: Vec<usize> = grammar
                .productions
                .iter()
                .enumerate()
                .filter(|(_, p)| p.lhs == id)
                .map(|(i, _)| i)
                .collect();
            let rhs_prods: Vec<usize> = grammar
                .productions
                .iter()
                .enumerate()
                .filter(|(_, p)| p.rhs.contains(&id))
                .map(|(i, _)| i)
                .collect();

            writeln!(w)?;
            if !lhs_prods.is_empty() {
                write!(w, "    on left:")?;
                for p in &lhs_prods {
                    write!(w, " {}", p)?;
                }
                writeln!(w)?;
            }
            if !rhs_prods.is_empty() {
                write!(w, "    on right:")?;
                for p in &rhs_prods {
                    write!(w, " {}", p)?;
                }
                writeln!(w)?;
            }
        }
    }
    writeln!(w)?;

    // State descriptions
    writeln!(w, "State descriptions")?;
    writeln!(w)?;

    for state in &lalr.lr0.states {
        writeln!(w, "State {}", state.id)?;
        writeln!(w)?;

        // Items
        for &item in &state.items {
            let prod = &grammar.productions[item.production];
            write!(w, "    {} -> ", grammar.symbol_name(prod.lhs))?;
            for (i, &sym) in prod.rhs.iter().enumerate() {
                if i == item.dot {
                    write!(w, ". ")?;
                }
                write!(w, "{} ", grammar.symbol_name(sym))?;
            }
            if item.dot >= prod.rhs.len() {
                write!(w, ".")?;
            }
            writeln!(w)?;
        }
        writeln!(w)?;

        // Actions
        if let Some(actions) = lalr.action_table.get(state.id) {
            for (&sym, action) in actions {
                let action_str = match action {
                    Action::Shift(s) => format!("shift, and go to state {}", s),
                    Action::Reduce(r) => format!("reduce using rule {}", r),
                    Action::Accept => "accept".to_string(),
                    Action::Error => "error".to_string(),
                };
                writeln!(w, "    {}  {}", grammar.symbol_name(sym), action_str)?;
            }
        }

        // Gotos
        if let Some(gotos) = lalr.goto_table.get(state.id) {
            for (&sym, &target) in gotos {
                writeln!(
                    w,
                    "    {}  go to state {}",
                    grammar.symbol_name(sym),
                    target
                )?;
            }
        }

        writeln!(w)?;
    }

    // Conflict summary
    // Grammar summary (per POSIX: "Limits for internal tables... shall also be reported")
    writeln!(w)?;
    writeln!(w, "Grammar summary")?;
    writeln!(w, "  Terminals:     {:5}", grammar.num_terminals)?;
    writeln!(w, "  Non-terminals: {:5}", grammar.num_nonterminals)?;
    writeln!(w, "  Rules:         {:5}", grammar.productions.len())?;
    writeln!(w, "  States:        {:5}", lalr.lr0.states.len())?;
    writeln!(
        w,
        "  Actions:       {:5}",
        lalr.action_table.iter().map(|a| a.len()).sum::<usize>()
    )?;

    let (sr, rr) = lalr.count_conflicts();
    if sr > 0 || rr > 0 {
        writeln!(w)?;
        writeln!(w, "Conflicts:")?;
        if sr > 0 {
            writeln!(w, "  {} shift/reduce", sr)?;
        }
        if rr > 0 {
            writeln!(w, "  {} reduce/reduce", rr)?;
        }

        // P3-2: Detailed conflict information per state
        writeln!(w)?;
        writeln!(w, "Conflict details:")?;

        // Group conflicts by state
        let mut by_state: BTreeMap<usize, Vec<(usize, &Vec<Action>)>> = BTreeMap::new();
        for ((state, sym), actions) in &lalr.conflicts {
            by_state.entry(*state).or_default().push((*sym, actions));
        }

        for (state_id, conflicts) in by_state {
            writeln!(w, "  State {}:", state_id)?;
            for (sym_id, actions) in conflicts {
                let sym_name = grammar.symbol_name(sym_id);
                let shifts: Vec<_> = actions
                    .iter()
                    .filter_map(|a| match a {
                        Action::Shift(s) => Some(*s),
                        _ => None,
                    })
                    .collect();
                let reduces: Vec<_> = actions
                    .iter()
                    .filter_map(|a| match a {
                        Action::Reduce(r) => Some(*r),
                        _ => None,
                    })
                    .collect();

                if !shifts.is_empty() && !reduces.is_empty() {
                    write!(w, "    {} : shift/reduce (", sym_name)?;
                    write!(w, "shift {}", shifts[0])?;
                    for r in &reduces {
                        write!(w, ", reduce {}", r)?;
                    }
                    writeln!(w, ")")?;
                } else if reduces.len() > 1 {
                    write!(w, "    {} : reduce/reduce (", sym_name)?;
                    for (i, r) in reduces.iter().enumerate() {
                        if i > 0 {
                            write!(w, ", ")?;
                        }
                        write!(w, "reduce {}", r)?;
                    }
                    writeln!(w, ")")?;
                }
            }
        }
    }

    w.flush()
        .map_err(|e| YaccError::Io(format!("error writing '{}': {}", path, e)))?;

    Ok(())
}

impl From<std::io::Error> for YaccError {
    fn from(e: std::io::Error) -> Self {
        YaccError::Io(e.to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_stack_reference_positive() {
        // For a rule with 3 RHS symbols:
        // $1 -> yyvsp[-2], $2 -> yyvsp[-1], $3 -> yyvsp[0]
        assert_eq!(generate_stack_reference(1, 3, None, "yy"), "(yyvsp[-2])");
        assert_eq!(generate_stack_reference(2, 3, None, "yy"), "(yyvsp[-1])");
        assert_eq!(generate_stack_reference(3, 3, None, "yy"), "(yyvsp[0])");
    }

    #[test]
    fn test_generate_stack_reference_zero_and_negative() {
        // For a rule with 3 RHS symbols:
        // $0 -> yyvsp[-3] (one before the rule)
        // $-1 -> yyvsp[-4] (two before the rule)
        // $-2 -> yyvsp[-5]
        assert_eq!(generate_stack_reference(0, 3, None, "yy"), "(yyvsp[-3])");
        assert_eq!(generate_stack_reference(-1, 3, None, "yy"), "(yyvsp[-4])");
        assert_eq!(generate_stack_reference(-2, 3, None, "yy"), "(yyvsp[-5])");
    }

    #[test]
    fn test_generate_stack_reference_with_tag() {
        // With explicit type tags
        assert_eq!(
            generate_stack_reference(1, 2, Some("ival"), "yy"),
            "(yyvsp[-1].ival)"
        );
        assert_eq!(
            generate_stack_reference(2, 2, Some("ival"), "yy"),
            "(yyvsp[0].ival)"
        );
        assert_eq!(
            generate_stack_reference(0, 2, Some("sval"), "yy"),
            "(yyvsp[-2].sval)"
        );
        assert_eq!(
            generate_stack_reference(-1, 2, Some("sval"), "yy"),
            "(yyvsp[-3].sval)"
        );
    }

    #[test]
    fn test_generate_stack_reference_empty_rhs() {
        // For an empty rule (epsilon production), rhs_len = 0
        // $0 -> yyvsp[0] (the symbol just before where we are)
        // Actually for empty RHS, $0 refers to yyvsp[0 - 0] = yyvsp[0]
        // which is the top of the stack before reduction
        assert_eq!(generate_stack_reference(0, 0, None, "yy"), "(yyvsp[0])");
        assert_eq!(generate_stack_reference(-1, 0, None, "yy"), "(yyvsp[-1])");
    }

    #[test]
    fn test_generate_stack_reference_single_rhs() {
        // For a rule with 1 RHS symbol:
        // $1 -> yyvsp[0] (the only symbol)
        // $0 -> yyvsp[-1] (one before)
        assert_eq!(generate_stack_reference(1, 1, None, "yy"), "(yyvsp[0])");
        assert_eq!(generate_stack_reference(0, 1, None, "yy"), "(yyvsp[-1])");
        assert_eq!(generate_stack_reference(-1, 1, None, "yy"), "(yyvsp[-2])");
    }

    #[test]
    fn test_generate_stack_reference_custom_prefix() {
        // Test with a custom prefix (for -p option)
        assert_eq!(generate_stack_reference(1, 2, None, "foo"), "(foovsp[-1])");
        assert_eq!(generate_stack_reference(2, 2, None, "foo"), "(foovsp[0])");
        assert_eq!(
            generate_stack_reference(1, 2, Some("ival"), "my"),
            "(myvsp[-1].ival)"
        );
    }
}
