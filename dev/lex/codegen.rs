//
// Copyright (c) 2024 Jeff Garzik
//
// This file is part of the posixutils-rs project covered under
// the MIT License.  For the full license text, please see the LICENSE
// file in the root directory of this project.
// SPDX-License-Identifier: MIT
//

//! Direct-coded C code generation for the lexical analyzer.
//!
//! This module generates POSIX-compliant C code from the DFA using a direct-coded
//! approach where each DFA state becomes a C label with switch-based transitions.
//! This is inspired by re2c's code generation strategy.

use crate::dfa::{Dfa, DfaInput, DfaState};
use crate::lexfile::LexInfo;
use std::collections::BTreeMap;
use std::io::{self, Write};

/// Rule metadata for code generation
#[derive(Clone, Default)]
pub struct RuleMetadata {
    /// True if rule is anchored to beginning of line (^)
    pub bol_anchor: bool,
    /// Fixed length of main pattern if known (for trailing context rules)
    /// When present, yyleng is set to this value (excluding trailing context)
    pub main_pattern_len: Option<usize>,
    /// True if this rule has trailing context
    pub has_trailing_context: bool,
    /// True if this rule has variable-length trailing context
    /// (main pattern length is not fixed, requires runtime tracking)
    pub has_variable_trailing_context: bool,
}

/// Configuration for code generation
pub struct CodeGenConfig {
    /// Whether yytext is a pointer (true) or array (false)
    pub yytext_is_pointer: bool,
    /// Buffer size for yytext when using array
    pub yytext_size: usize,
    /// Start condition names (INITIAL is always index 0)
    pub start_conditions: Vec<String>,
    /// Metadata for each rule (indexed by rule number)
    pub rule_metadata: Vec<RuleMetadata>,
}

impl Default for CodeGenConfig {
    fn default() -> Self {
        CodeGenConfig {
            yytext_is_pointer: true,
            yytext_size: 8192,
            start_conditions: vec!["INITIAL".to_string()],
            rule_metadata: Vec::new(),
        }
    }
}

/// Generate the complete lex.yy.c output using direct-coded generation
pub fn generate<W: Write>(
    output: &mut W,
    dfa: &Dfa,
    lexinfo: &LexInfo,
    config: &CodeGenConfig,
) -> io::Result<()> {
    // Log generation info
    eprintln!(
        "lex: {} states, {} equivalence classes -> direct-coded generation",
        dfa.states.len(),
        dfa.char_classes.num_classes
    );

    // Determine if we need accept lists for alternate rule finding
    let has_reject = lexinfo.rules.iter().any(|r| r.action.contains("REJECT"));
    let has_start_conditions = config.start_conditions.len() > 1;
    let has_bol_anchors = config.rule_metadata.iter().any(|m| m.bol_anchor);
    let needs_accept_lists = has_reject || has_start_conditions || has_bol_anchors;

    write_header(output)?;
    write_includes(output)?;
    write_external_definitions(output, lexinfo)?;
    write_macros_and_types(output, config)?;
    write_char_class_table(output, dfa)?;
    write_num_states(output, dfa)?;
    // Only generate accept lists if needed for REJECT or alternate rule finding
    if needs_accept_lists {
        write_accepting_list_table(output, dfa)?;
    }
    write_rule_condition_table(output, lexinfo, config)?;
    write_rule_metadata_tables(output, lexinfo, config)?;
    write_main_pattern_end_table(output, dfa, config)?;
    write_helper_functions(output, lexinfo)?;
    write_yylex_direct_coded(output, dfa, lexinfo, config)?;
    write_user_subroutines(output, lexinfo)?;

    Ok(())
}

fn write_header<W: Write>(output: &mut W) -> io::Result<()> {
    writeln!(output, "/* Generated by lex-rs - POSIX compatible lex */")?;
    writeln!(output, "/* Direct-coded scanner (re2c-style) */")?;
    writeln!(
        output,
        "/* DO NOT EDIT - This file was automatically generated */\n"
    )?;
    Ok(())
}

fn write_includes<W: Write>(output: &mut W) -> io::Result<()> {
    writeln!(
        output,
        r#"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Forward declarations */
int yywrap(void);
"#
    )?;
    Ok(())
}

fn write_external_definitions<W: Write>(output: &mut W, lexinfo: &LexInfo) -> io::Result<()> {
    if !lexinfo.external_def.is_empty() {
        writeln!(output, "/* User external definitions */")?;
        for line in &lexinfo.external_def {
            write!(output, "{}", line)?;
        }
        writeln!(output)?;
    }
    Ok(())
}

fn write_macros_and_types<W: Write>(output: &mut W, config: &CodeGenConfig) -> io::Result<()> {
    writeln!(
        output,
        r#"/* Lex macros and types */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

#ifndef ECHO
#define ECHO fwrite(yytext, yyleng, 1, yyout)
#endif

#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size) \
    do {{ \
        if (yyin == NULL) yyin = stdin; \
        if (feof(yyin)) {{ result = 0; }} \
        else {{ \
            result = fread(buf, 1, max_size, yyin); \
        }} \
    }} while (0)
#endif
"#
    )?;

    // Generate start condition defines
    writeln!(output, "/* Start condition states */")?;
    for (idx, name) in config.start_conditions.iter().enumerate() {
        writeln!(output, "#define {} {}", name, idx)?;
    }
    writeln!(output)?;

    // BEGIN and YY_START macros - only use yy_start_state if there are multiple conditions
    let has_start_conditions = config.start_conditions.len() > 1;
    if has_start_conditions {
        writeln!(
            output,
            r#"#ifndef BEGIN
#define BEGIN(x) (yy_start_state = (x))
#endif

#ifndef YY_START
#define YY_START yy_start_state
#endif
"#
        )?;
    } else {
        // With only INITIAL, BEGIN is a no-op and YY_START is always 0
        writeln!(
            output,
            r#"#ifndef BEGIN
#define BEGIN(x) ((void)0)
#endif

#ifndef YY_START
#define YY_START INITIAL
#endif
"#
        )?;
    }

    // yytext declaration
    if config.yytext_is_pointer {
        writeln!(
            output,
            r#"/* yytext as pointer */
static char yy_yytext_buf[YY_BUF_SIZE + 1];
char *yytext = yy_yytext_buf;
"#
        )?;
    } else {
        writeln!(output, "/* yytext as array */")?;
        writeln!(output, "#define YYLMAX {}", config.yytext_size)?;
        writeln!(output, "char yytext[YYLMAX];\n")?;
    }

    writeln!(
        output,
        r#"/* Standard lex variables */
int yyleng;
FILE *yyin = NULL;
FILE *yyout = NULL;"#
    )?;
    // Only generate yy_start_state when there are multiple start conditions
    if has_start_conditions {
        writeln!(output, "static int yy_start_state = INITIAL;")?;
    }
    writeln!(
        output,
        r#"
/* Input buffer */
static unsigned char yy_buffer[YY_BUF_SIZE + 2];
static unsigned char *YYCURSOR = yy_buffer;
static unsigned char *YYLIMIT = yy_buffer;
static unsigned char *YYTOKEN = yy_buffer;
static unsigned char *YYMARKER = yy_buffer;
static int yyaccept = -1;

/* Beginning of line tracking */
static int yy_at_bol = 1; /* Start at beginning of line */

/* REJECT support */
static int yy_reject_flag = 0;
static int yy_full_match_state = 0;  /* DFA state where match occurred */
static int yy_full_match_rule_idx = 0;  /* Index within accepting list */

/* Buffer refill resume state */
static int yy_resume_state = 0;  /* DFA state to resume from after refill */

#ifndef REJECT
#define REJECT {{ yy_reject_flag = 1; goto yy_find_next_match; }}
#endif

/* yymore support */
static int yy_more_flag = 0;
static int yy_more_len = 0;

#ifndef yymore
#define yymore() (yy_more_flag = 1)
#endif

/* yyless - return characters to input */
#ifndef yyless
#define yyless(n) do {{ \
    YYCURSOR = YYTOKEN + (n); \
    yyleng = (n); \
    yytext[yyleng] = '\0'; \
}} while (0)
#endif

/* unput now always inserts directly into main buffer - no separate pushback buffer */
"#
    )?;

    // Variable-length trailing context support - only emit if any rule uses it
    let has_var_tc = config
        .rule_metadata
        .iter()
        .any(|m| m.has_variable_trailing_context);
    if has_var_tc {
        writeln!(output, "/* Variable-length trailing context support */")?;
        writeln!(
            output,
            "static unsigned char *yy_main_end_ptr = NULL; /* Position where main pattern ended */"
        )?;
        writeln!(
            output,
            "static int yy_main_end_rule = -1; /* Which rule's main pattern ended there */"
        )?;
        writeln!(output)?;
    }

    Ok(())
}

fn write_char_class_table<W: Write>(output: &mut W, dfa: &Dfa) -> io::Result<()> {
    writeln!(output, "/* Character to equivalence class mapping */")?;
    writeln!(
        output,
        "#define YY_NUM_CLASSES {}",
        dfa.char_classes.num_classes
    )?;
    write!(output, "static const unsigned char yy_ec[256] = {{")?;

    for (i, &class) in dfa.char_classes.char_to_class.iter().enumerate() {
        if i % 16 == 0 {
            write!(output, "\n    ")?;
        }
        write!(output, "{:3}", class)?;
        if i < 255 {
            write!(output, ",")?;
        }
    }

    writeln!(output, "\n}};\n")?;

    Ok(())
}

fn write_num_states<W: Write>(output: &mut W, dfa: &Dfa) -> io::Result<()> {
    writeln!(output, "#define YY_NUM_STATES {}", dfa.states.len())?;
    writeln!(output)?;
    Ok(())
}

/// Write the accepting rules list for REJECT support
fn write_accepting_list_table<W: Write>(output: &mut W, dfa: &Dfa) -> io::Result<()> {
    // Build the flattened list and index array
    let mut accept_list: Vec<i16> = Vec::new();
    let mut accept_idx: Vec<usize> = Vec::new();

    for state in &dfa.states {
        accept_idx.push(accept_list.len());
        for &rule in &state.accepting_rules {
            accept_list.push(rule as i16);
        }
    }
    accept_idx.push(accept_list.len()); // Sentinel for last state

    writeln!(output, "/* Accepting rules list for REJECT support */")?;
    writeln!(
        output,
        "/* yy_accept_list[yy_accept_idx[state]..yy_accept_idx[state+1]] gives all rules */"
    )?;

    // Write the index array
    write!(
        output,
        "static const unsigned short yy_accept_idx[YY_NUM_STATES + 1] = {{ "
    )?;
    for (i, idx) in accept_idx.iter().enumerate() {
        if i > 0 {
            write!(output, ", ")?;
        }
        write!(output, "{}", idx)?;
    }
    writeln!(output, " }};\n")?;

    // Write the rules list
    if accept_list.is_empty() {
        writeln!(output, "static const short yy_accept_list[1] = {{ -1 }};\n")?;
    } else {
        write!(
            output,
            "static const short yy_accept_list[{}] = {{ ",
            accept_list.len()
        )?;
        for (i, rule) in accept_list.iter().enumerate() {
            if i > 0 {
                write!(output, ", ")?;
            }
            write!(output, "{}", rule)?;
        }
        writeln!(output, " }};\n")?;
    }

    Ok(())
}

/// Write a table indicating which rules are active in which start conditions
fn write_rule_condition_table<W: Write>(
    output: &mut W,
    lexinfo: &LexInfo,
    config: &CodeGenConfig,
) -> io::Result<()> {
    let num_rules = lexinfo.rules.len();
    let num_conditions = config.start_conditions.len();

    // Only generate the table if we have more than just INITIAL
    if num_conditions <= 1 {
        return Ok(());
    }

    writeln!(output, "/* Rule active-in-condition table */")?;
    writeln!(
        output,
        "/* yy_rule_cond[rule][condition] = 1 if rule is active in that condition */"
    )?;
    writeln!(output, "#define YY_NUM_RULES {}", num_rules)?;
    writeln!(output, "#define YY_NUM_CONDITIONS {}", num_conditions)?;
    writeln!(
        output,
        "static const unsigned char yy_rule_cond[YY_NUM_RULES][YY_NUM_CONDITIONS] = {{"
    )?;

    for (rule_idx, rule) in lexinfo.rules.iter().enumerate() {
        write!(output, "    /* rule {} */ {{ ", rule_idx)?;
        for (cond_idx, cond_name) in config.start_conditions.iter().enumerate() {
            let active = is_rule_active_in_condition(rule, cond_name, lexinfo);
            if cond_idx > 0 {
                write!(output, ", ")?;
            }
            write!(output, "{}", if active { 1 } else { 0 })?;
        }
        writeln!(output, " }},")?;
    }

    writeln!(output, "}};\n")?;

    Ok(())
}

/// Check if a rule is active in a given start condition
fn is_rule_active_in_condition(
    rule: &crate::lexfile::LexRule,
    condition: &str,
    lexinfo: &LexInfo,
) -> bool {
    // If rule has explicit start conditions, check if this condition is listed
    if !rule.start_conditions.is_empty() {
        return rule.start_conditions.contains(&condition.to_string());
    }

    // Rule has no explicit conditions
    // For INITIAL or %s (inclusive) conditions, the rule is active
    // For %x (exclusive) conditions, the rule is NOT active
    if condition == "INITIAL" || lexinfo.cond_start.contains(&condition.to_string()) {
        return true;
    }

    // This is an exclusive condition (%x), and rule has no explicit conditions
    false
}

/// Write rule metadata tables for BOL anchoring and trailing context
fn write_rule_metadata_tables<W: Write>(
    output: &mut W,
    lexinfo: &LexInfo,
    config: &CodeGenConfig,
) -> io::Result<()> {
    let num_rules = lexinfo.rules.len();
    if num_rules == 0 {
        return Ok(());
    }

    // Check if any rules have BOL anchoring
    let has_bol_anchors = config.rule_metadata.iter().any(|m| m.bol_anchor);

    // Check if any rules have trailing context
    let has_trailing_context = config.rule_metadata.iter().any(|m| m.has_trailing_context);

    // Define YY_NUM_RULES if needed for BOL or trailing context checks
    if (has_bol_anchors || has_trailing_context) && config.start_conditions.len() <= 1 {
        writeln!(output, "#ifndef YY_NUM_RULES")?;
        writeln!(output, "#define YY_NUM_RULES {}", num_rules)?;
        writeln!(output, "#endif\n")?;
    }

    if has_bol_anchors {
        // Write BOL anchor table (1 = rule requires BOL, 0 = no requirement)
        writeln!(
            output,
            "/* BOL anchor table - 1 if rule requires beginning of line */"
        )?;
        write!(output, "static const int yy_rule_bol[{}] = {{ ", num_rules)?;
        for (i, rule) in lexinfo.rules.iter().enumerate() {
            let bol = if i < config.rule_metadata.len() {
                config.rule_metadata[i].bol_anchor
            } else {
                rule.bol_anchor
            };
            write!(output, "{}", if bol { 1 } else { 0 })?;
            if i < num_rules - 1 {
                write!(output, ", ")?;
            }
        }
        writeln!(output, " }};\n")?;
    }

    if has_trailing_context {
        writeln!(
            output,
            "/* Main pattern length table (for trailing context) */"
        )?;
        writeln!(
            output,
            "/* -1 = no trailing context, >= 0 = fixed main pattern length, -2 = variable */"
        )?;
        write!(
            output,
            "static const int yy_rule_main_len[{}] = {{ ",
            num_rules
        )?;
        for (i, _) in lexinfo.rules.iter().enumerate() {
            let main_len = if i < config.rule_metadata.len() {
                let meta = &config.rule_metadata[i];
                if meta.has_trailing_context {
                    match meta.main_pattern_len {
                        Some(len) => len as i32,
                        None => -2, // Variable length main pattern
                    }
                } else {
                    -1 // No trailing context
                }
            } else {
                -1
            };
            write!(output, "{}", main_len)?;
            if i < num_rules - 1 {
                write!(output, ", ")?;
            }
        }
        writeln!(output, " }};\n")?;
    }

    Ok(())
}

/// Write table mapping DFA states to main pattern end rules (for variable-length trailing context)
fn write_main_pattern_end_table<W: Write>(
    _output: &mut W,
    _dfa: &Dfa,
    _config: &CodeGenConfig,
) -> io::Result<()> {
    // Note: yy_state_main_end and yy_rule_var_tc tables were originally generated here
    // but are unused - the implementation uses yy_main_end_ptr/yy_main_end_rule directly
    // at runtime instead of static tables. Removed to avoid unused variable warnings.
    Ok(())
}

fn write_helper_functions<W: Write>(output: &mut W, lexinfo: &LexInfo) -> io::Result<()> {
    // input() function - conditionally generated based on %option noinput
    if !lexinfo.options.noinput {
        writeln!(
            output,
            r#"/* input - read one character from input */
static int input(void)
{{
    /* Check main buffer - unput() now always inserts directly here */
    if (YYCURSOR < YYLIMIT) {{
        return *YYCURSOR++;
    }}
    /* Need to refill buffer */
    if (yyin == NULL) yyin = stdin;
    return getc(yyin);  /* Returns EOF (-1) on end of file */
}}
"#
        )?;
    }

    // unput() function - conditionally generated based on %option nounput
    if !lexinfo.options.nounput {
        writeln!(
            output,
            r#"/* unput - push character back to input */
/* Always inserts directly into main buffer so DFA sees it immediately */
static void unput(int c)
{{
    if (YYCURSOR > yy_buffer) {{
        /* Simple case: push back into main buffer */
        *--YYCURSOR = (unsigned char)c;
    }} else {{
        /* At start of buffer - need to shift content right to make room */
        int yy_remain = YYLIMIT - yy_buffer;
        if (yy_remain > 0 && yy_remain < YY_BUF_SIZE) {{
            memmove(yy_buffer + 1, yy_buffer, yy_remain);
        }}
        yy_buffer[0] = (unsigned char)c;
        YYLIMIT++;
        /* YYCURSOR stays at yy_buffer, now pointing to inserted char */
    }}
}}
"#
        )?;
    }

    Ok(())
}

/// Build a map of equivalence class -> target state for transitions from a DFA state
fn build_class_transitions(dfa: &Dfa, state: &DfaState) -> BTreeMap<usize, usize> {
    let mut class_to_target: BTreeMap<usize, usize> = BTreeMap::new();

    for (input, &target) in &state.transitions {
        let DfaInput::Char(ch) = input;
        let ch_code = *ch as u32;
        if ch_code < 256 {
            let class_idx = dfa.char_classes.char_to_class[ch_code as usize] as usize;
            class_to_target.insert(class_idx, target);
        }
    }

    class_to_target
}

/// Write a single DFA state as a labeled block with switch-based transitions
fn write_dfa_state<W: Write>(
    output: &mut W,
    dfa: &Dfa,
    state_idx: usize,
    state: &DfaState,
    config: &CodeGenConfig,
) -> io::Result<()> {
    writeln!(output, "yy_state_{}:", state_idx)?;

    // If this is an accepting state, save marker position and state info
    if let Some(rule) = state.accepting {
        writeln!(output, "    /* Accepting state for rule {} */", rule)?;
        writeln!(output, "    YYMARKER = YYCURSOR;")?;
        writeln!(output, "    yyaccept = {};", rule)?;
        writeln!(output, "    yy_full_match_state = {};", state_idx)?;
    }

    // Track main pattern end for variable-length trailing context
    let has_var_tc = config
        .rule_metadata
        .iter()
        .any(|m| m.has_variable_trailing_context);
    if has_var_tc && !state.main_pattern_end_rules.is_empty() {
        let rule = state.main_pattern_end_rules[0];
        if rule < config.rule_metadata.len()
            && config.rule_metadata[rule].has_variable_trailing_context
        {
            writeln!(output, "    /* Main pattern ends here for rule {} */", rule)?;
            writeln!(output, "    yy_main_end_ptr = YYCURSOR;")?;
            writeln!(output, "    yy_main_end_rule = {};", rule)?;
        }
    }

    // Check for end of input - save state for resume after refill
    writeln!(
        output,
        "    if (YYCURSOR >= YYLIMIT) {{ yy_resume_state = {}; goto yy_fill_or_eof; }}",
        state_idx
    )?;

    // Read next character and switch on equivalence class
    writeln!(output, "    switch (yy_ec[*YYCURSOR++]) {{")?;

    // Get transitions grouped by equivalence class
    let transitions = build_class_transitions(dfa, state);

    for (class, target) in &transitions {
        writeln!(output, "        case {}: goto yy_state_{};", class, target)?;
    }

    writeln!(output, "        default: goto yy_fail;")?;
    writeln!(output, "    }}")?;
    writeln!(output)?;

    Ok(())
}

/// Write the direct-coded yylex function
fn write_yylex_direct_coded<W: Write>(
    output: &mut W,
    dfa: &Dfa,
    lexinfo: &LexInfo,
    config: &CodeGenConfig,
) -> io::Result<()> {
    let has_start_conditions = config.start_conditions.len() > 1;
    let has_bol_anchors = config.rule_metadata.iter().any(|m| m.bol_anchor);
    let has_trailing_context = config.rule_metadata.iter().any(|m| m.has_trailing_context);
    let has_var_tc = config
        .rule_metadata
        .iter()
        .any(|m| m.has_variable_trailing_context);
    let eof_rule_idx = lexinfo.rules.iter().position(|r| r.is_eof);
    // Check if any rule uses REJECT macro
    let has_reject = lexinfo.rules.iter().any(|r| r.action.contains("REJECT"));

    writeln!(output, "/* The main lexer function - direct coded */")?;
    writeln!(output, "int yylex(void)")?;
    writeln!(output, "{{")?;

    // Initialize yyin/yyout
    writeln!(output, "    if (yyin == NULL) yyin = stdin;")?;
    writeln!(output, "    if (yyout == NULL) yyout = stdout;")?;
    writeln!(output)?;

    // Main scanning loop entry point
    writeln!(output, "yy_scan:")?;

    // User code from indented lines before first rule
    if !lexinfo.internal_defs.is_empty() {
        writeln!(
            output,
            "    /* User code from rules section (runs on each yylex call) */"
        )?;
        for line in &lexinfo.internal_defs {
            write!(output, "    {}", line)?;
        }
        writeln!(output)?;
    }

    // Buffer refill check
    writeln!(output, "    /* Check if buffer needs refill */")?;
    writeln!(output, "    if (YYCURSOR >= YYLIMIT) {{")?;
    writeln!(output, "        int yy_result;")?;
    writeln!(
        output,
        "        /* unput() inserts directly into buffer, no separate drain needed */"
    )?;
    writeln!(
        output,
        "        YY_INPUT(yy_buffer, yy_result, YY_BUF_SIZE);"
    )?;
    writeln!(output, "        YYLIMIT = yy_buffer + yy_result;")?;
    writeln!(output, "        YYCURSOR = yy_buffer;")?;
    writeln!(output, "        if (yy_result == 0) {{")?;

    // Handle EOF
    if let Some(idx) = eof_rule_idx {
        writeln!(output, "            /* Execute <<EOF>> rule */")?;
        writeln!(output, "            yyleng = 0;")?;
        writeln!(output, "            yytext[0] = '\\0';")?;
        writeln!(output, "            goto yy_action_{};", idx)?;
    } else {
        writeln!(output, "            /* EOF - call yywrap() */")?;
        writeln!(output, "            if (yywrap()) return 0;")?;
        writeln!(output, "            goto yy_scan;")?;
    }
    writeln!(output, "        }}")?;
    writeln!(output, "    }}")?;
    writeln!(output)?;

    // Initialize for new token
    writeln!(output, "    /* Initialize for new token */")?;
    writeln!(output, "    YYTOKEN = YYCURSOR;")?;
    writeln!(output, "    yyaccept = -1;")?;
    writeln!(output, "    yy_reject_flag = 0;")?;
    writeln!(output, "    yy_full_match_state = 0;")?;
    writeln!(output, "    yy_full_match_rule_idx = 0;")?;
    if has_var_tc {
        writeln!(output, "    yy_main_end_ptr = YYCURSOR;")?;
        writeln!(output, "    yy_main_end_rule = -1;")?;
    }
    // Save BOL status at token start (for BOL anchor validation)
    if has_bol_anchors {
        writeln!(output, "    int yy_token_at_bol = yy_at_bol;")?;
    }
    writeln!(output)?;

    // Start condition dispatch
    if has_start_conditions {
        writeln!(output, "    /* Dispatch based on start condition */")?;
        writeln!(output, "    switch (yy_start_state) {{")?;
        for (idx, name) in config.start_conditions.iter().enumerate() {
            // For now, all start conditions share state 0
            // A more sophisticated implementation would have separate start states
            writeln!(
                output,
                "        case {}: /* {} */ goto yy_state_0;",
                idx, name
            )?;
        }
        writeln!(output, "        default: goto yy_state_0;")?;
        writeln!(output, "    }}")?;
    } else {
        writeln!(output, "    goto yy_state_0;")?;
    }
    writeln!(output)?;

    // Generate all DFA states
    for (state_idx, state) in dfa.states.iter().enumerate() {
        write_dfa_state(output, dfa, state_idx, state, config)?;
    }

    // YYFILL/EOF block
    writeln!(output, "yy_fill_or_eof:")?;
    writeln!(output, "    /* End of buffer reached during scan */")?;
    writeln!(
        output,
        "    /* Try to refill buffer - may find longer match */"
    )?;
    writeln!(output, "    {{")?;
    writeln!(output, "        int yy_result;")?;
    writeln!(
        output,
        "        /* Save current offsets relative to buffer */"
    )?;
    writeln!(output, "        int yy_token_offset = YYTOKEN - yy_buffer;")?;
    writeln!(
        output,
        "        int yy_cursor_offset = YYCURSOR - yy_buffer;"
    )?;
    writeln!(
        output,
        "        int yy_marker_offset = YYMARKER - yy_buffer;"
    )?;
    if has_var_tc {
        writeln!(
            output,
            "        int yy_main_end_offset = yy_main_end_ptr - yy_buffer;"
        )?;
    }
    writeln!(
        output,
        "        /* Shift remaining data to start of buffer */"
    )?;
    writeln!(output, "        int yy_remain = YYLIMIT - YYTOKEN;")?;
    writeln!(
        output,
        "        if (yy_remain > 0 && YYTOKEN > yy_buffer) {{"
    )?;
    writeln!(
        output,
        "            memmove(yy_buffer, YYTOKEN, yy_remain);"
    )?;
    writeln!(output, "        }}")?;
    writeln!(
        output,
        "        YY_INPUT(yy_buffer + yy_remain, yy_result, YY_BUF_SIZE - yy_remain);"
    )?;
    writeln!(output, "        if (yy_result == 0) {{")?;
    writeln!(
        output,
        "            /* True EOF - no more input available */"
    )?;
    writeln!(output, "            if (yy_remain == 0) {{")?;
    writeln!(
        output,
        "                /* Buffer completely empty - handle EOF */"
    )?;
    if let Some(idx) = eof_rule_idx {
        writeln!(output, "                yyleng = 0;")?;
        writeln!(output, "                yytext[0] = '\\0';")?;
        writeln!(output, "                goto yy_action_{};", idx)?;
    } else {
        writeln!(output, "                if (yywrap()) return 0;")?;
        writeln!(output, "                goto yy_scan;")?;
    }
    writeln!(output, "            }}")?;
    writeln!(
        output,
        "            /* Have remaining data - finalize with current match */"
    )?;
    writeln!(output, "            YYLIMIT = yy_buffer + yy_remain;")?;
    writeln!(output, "            YYTOKEN = yy_buffer;")?;
    writeln!(
        output,
        "            YYCURSOR = yy_buffer + (yy_cursor_offset - yy_token_offset);"
    )?;
    writeln!(
        output,
        "            YYMARKER = yy_buffer + (yy_marker_offset - yy_token_offset);"
    )?;
    if has_var_tc {
        writeln!(
            output,
            "            yy_main_end_ptr = yy_buffer + (yy_main_end_offset - yy_token_offset);"
        )?;
    }
    writeln!(output, "            if (yyaccept >= 0) {{")?;
    writeln!(output, "                goto yy_fail;")?;
    writeln!(output, "            }}")?;
    writeln!(
        output,
        "            /* No match - default action on remaining */"
    )?;
    writeln!(output, "            yy_at_bol = (*YYTOKEN == '\\n');")?;
    writeln!(output, "            putc(*YYTOKEN++, yyout);")?;
    writeln!(output, "            YYCURSOR = YYTOKEN;")?;
    writeln!(output, "            goto yy_scan;")?;
    writeln!(output, "        }}")?;
    writeln!(
        output,
        "        /* Refill succeeded - adjust pointers and resume scanning */"
    )?;
    writeln!(
        output,
        "        YYLIMIT = yy_buffer + yy_remain + yy_result;"
    )?;
    writeln!(output, "        YYTOKEN = yy_buffer;")?;
    writeln!(
        output,
        "        YYCURSOR = yy_buffer + (yy_cursor_offset - yy_token_offset);"
    )?;
    writeln!(
        output,
        "        YYMARKER = yy_buffer + (yy_marker_offset - yy_token_offset);"
    )?;
    if has_var_tc {
        writeln!(
            output,
            "        yy_main_end_ptr = yy_buffer + (yy_main_end_offset - yy_token_offset);"
        )?;
    }
    writeln!(
        output,
        "        /* Resume scanning from the DFA state that hit buffer end */"
    )?;
    writeln!(output, "        switch (yy_resume_state) {{")?;
    for state_idx in 0..dfa.states.len() {
        writeln!(
            output,
            "            case {}: goto yy_state_{};",
            state_idx, state_idx
        )?;
    }
    writeln!(output, "            default: goto yy_state_0;")?;
    writeln!(output, "        }}")?;
    writeln!(output, "    }}")?;
    writeln!(output)?;

    // YYFAIL block - handle match or default action
    writeln!(output, "yy_fail:")?;
    // Only generate yy_find_next_match label if any rule uses REJECT
    if has_reject {
        writeln!(output, "yy_find_next_match:")?;
    }
    writeln!(output, "    /* Match failed or end of automaton reached */")?;
    writeln!(output, "    if (yyaccept < 0) {{")?;
    writeln!(
        output,
        "        /* No match - default action (ECHO one char) */"
    )?;
    writeln!(output, "        if (YYTOKEN < YYLIMIT) {{")?;
    writeln!(output, "            yy_at_bol = (*YYTOKEN == '\\n');")?;
    writeln!(output, "            putc(*YYTOKEN++, yyout);")?;
    writeln!(output, "            YYCURSOR = YYTOKEN;")?;
    writeln!(output, "            goto yy_scan;")?;
    writeln!(output, "        }}")?;
    writeln!(output, "        /* EOF - consult yywrap() */")?;
    writeln!(output, "        if (yywrap()) return 0;")?;
    writeln!(output, "        goto yy_scan;")?;
    writeln!(output, "    }}")?;
    writeln!(output)?;

    // REJECT support - only generate if any rule uses REJECT
    if has_reject {
        writeln!(
            output,
            "    /* REJECT support: find next valid rule at this position */"
        )?;
        writeln!(output, "    if (yy_reject_flag) {{")?;
        writeln!(output, "        int yy_found = 0;")?;
        writeln!(output, "        int yy_i;")?;
        writeln!(
            output,
            "        int yy_start_idx = yy_accept_idx[yy_full_match_state];"
        )?;
        writeln!(
            output,
            "        int yy_end_idx = yy_accept_idx[yy_full_match_state + 1];"
        )?;
        writeln!(output, "        int yy_skip_until_after = yyaccept;")?;
        writeln!(output, "        int yy_skipping = 1;")?;
        writeln!(
            output,
            "        for (yy_i = yy_start_idx; yy_i < yy_end_idx; yy_i++) {{"
        )?;
        writeln!(output, "            int yy_rule = yy_accept_list[yy_i];")?;
        writeln!(
            output,
            "            if (yy_skipping) {{ if (yy_rule == yy_skip_until_after) yy_skipping = 0; continue; }}"
        )?;
        if has_start_conditions {
            writeln!(
                output,
                "            if (!yy_rule_cond[yy_rule][yy_start_state]) continue;"
            )?;
        }
        if has_bol_anchors {
            writeln!(
                output,
                "            if (yy_rule_bol[yy_rule] && !yy_token_at_bol) continue;"
            )?;
        }
        writeln!(output, "            yyaccept = yy_rule;")?;
        writeln!(output, "            yy_found = 1;")?;
        writeln!(output, "            break;")?;
        writeln!(output, "        }}")?;
        writeln!(output, "        if (!yy_found) {{")?;
        writeln!(
            output,
            "            /* No alternate rule at this position, fall through to default */"
        )?;
        writeln!(output, "            yy_at_bol = (*YYTOKEN == '\\n');")?;
        writeln!(output, "            putc(*YYTOKEN++, yyout);")?;
        writeln!(output, "            YYCURSOR = YYTOKEN;")?;
        writeln!(output, "            goto yy_scan;")?;
        writeln!(output, "        }}")?;
        writeln!(output, "        yy_reject_flag = 0;")?;
        writeln!(output, "    }}")?;
        writeln!(output)?;
    }

    // Rollback to marker and set yytext/yyleng
    writeln!(output, "    /* Rollback to accepted position */")?;
    writeln!(output, "    YYCURSOR = YYMARKER;")?;
    writeln!(output)?;

    // Set yytext and yyleng with yymore support
    writeln!(output, "    /* Set yytext and yyleng (handle yymore) */")?;
    writeln!(output, "    if (yy_more_flag) {{")?;
    writeln!(
        output,
        "        int yy_new_len = (int)(YYCURSOR - YYTOKEN);"
    )?;
    writeln!(
        output,
        "        memcpy(yytext + yy_more_len, YYTOKEN, yy_new_len);"
    )?;
    writeln!(output, "        yyleng = yy_more_len + yy_new_len;")?;
    writeln!(output, "        yytext[yyleng] = '\\0';")?;
    writeln!(output, "        yy_more_flag = 0;")?;
    writeln!(output, "    }} else {{")?;
    writeln!(output, "        yyleng = (int)(YYCURSOR - YYTOKEN);")?;
    writeln!(output, "        memcpy(yytext, YYTOKEN, yyleng);")?;
    writeln!(output, "        yytext[yyleng] = '\\0';")?;
    writeln!(output, "    }}")?;
    writeln!(output)?;

    // Handle trailing context
    if has_trailing_context {
        writeln!(output, "    /* Handle trailing context - adjust yyleng */")?;
        writeln!(
            output,
            "    if (yyaccept >= 0 && yyaccept < YY_NUM_RULES) {{"
        )?;
        writeln!(
            output,
            "        int yy_main_len = yy_rule_main_len[yyaccept];"
        )?;
        writeln!(output, "        if (yy_main_len >= 0) {{")?;
        writeln!(output, "            /* Fixed-length main pattern */")?;
        writeln!(output, "            YYCURSOR = YYTOKEN + yy_main_len;")?;
        writeln!(output, "            yyleng = yy_main_len;")?;
        writeln!(output, "            yytext[yyleng] = '\\0';")?;
        if has_var_tc {
            writeln!(output, "        }} else if (yy_main_len == -2) {{")?;
            writeln!(output, "            /* Variable-length main pattern */")?;
            writeln!(
                output,
                "            if (yy_main_end_rule == yyaccept && yy_main_end_ptr > YYTOKEN) {{"
            )?;
            writeln!(output, "                YYCURSOR = yy_main_end_ptr;")?;
            writeln!(
                output,
                "                yyleng = (int)(yy_main_end_ptr - YYTOKEN);"
            )?;
            writeln!(output, "                yytext[yyleng] = '\\0';")?;
            writeln!(output, "            }}")?;
        }
        writeln!(output, "        }}")?;
        writeln!(output, "    }}")?;
        writeln!(output)?;
    }

    // Save yy_more_len AFTER trailing context adjustment (Bug #5 fix)
    writeln!(output, "    yy_more_len = yyleng;")?;
    writeln!(output)?;

    // Save for REJECT (YYTOKEN stays at start of matched text for yyless to use)
    writeln!(output, "    yy_full_match_rule_idx = yyaccept;")?;
    writeln!(output)?;

    // Update BOL status for NEXT token (based on whether current match ends with newline)
    writeln!(
        output,
        "    /* Update beginning-of-line status for next token */"
    )?;
    writeln!(output, "    if (yyleng > 0) {{")?;
    writeln!(output, "        yy_at_bol = (yytext[yyleng - 1] == '\\n');")?;
    writeln!(output, "    }}")?;
    writeln!(output)?;

    // Start condition and BOL anchor validation
    if has_start_conditions || has_bol_anchors {
        writeln!(
            output,
            "    /* Validate rule against current start condition and BOL */"
        )?;
        // Note: removed yy_validate_rule: label as it was unused (no gotos to it)
        if has_start_conditions {
            writeln!(
                output,
                "    if (yyaccept >= 0 && !yy_rule_cond[yyaccept][yy_start_state]) {{"
            )?;
            writeln!(
                output,
                "        /* Rule not valid in current start condition */"
            )?;
            writeln!(output, "        goto yy_try_alternate_rule;")?;
            writeln!(output, "    }}")?;
        }
        if has_bol_anchors {
            writeln!(
                output,
                "    if (yyaccept >= 0 && yy_rule_bol[yyaccept] && !yy_token_at_bol) {{"
            )?;
            writeln!(
                output,
                "        /* BOL rule but not at beginning of line */"
            )?;
            writeln!(output, "        goto yy_try_alternate_rule;")?;
            writeln!(output, "    }}")?;
        }
        writeln!(output, "    goto yy_execute_action;")?;
        writeln!(output)?;

        // Try alternate rule (find next rule in accepting list)
        writeln!(output, "yy_try_alternate_rule:")?;
        writeln!(output, "    {{")?;
        writeln!(
            output,
            "        /* Find next valid rule at this position */"
        )?;
        writeln!(output, "        int yy_found = 0;")?;
        writeln!(output, "        int yy_i;")?;
        writeln!(
            output,
            "        int yy_start_idx = yy_accept_idx[yy_full_match_state];"
        )?;
        writeln!(
            output,
            "        int yy_end_idx = yy_accept_idx[yy_full_match_state + 1];"
        )?;
        writeln!(output, "        int yy_skip_until_after = yyaccept;")?;
        writeln!(output, "        int yy_skipping = 1;")?;
        writeln!(
            output,
            "        for (yy_i = yy_start_idx; yy_i < yy_end_idx; yy_i++) {{"
        )?;
        writeln!(output, "            int yy_rule = yy_accept_list[yy_i];")?;
        writeln!(
            output,
            "            if (yy_skipping) {{ if (yy_rule == yy_skip_until_after) yy_skipping = 0; continue; }}"
        )?;
        if has_start_conditions {
            writeln!(
                output,
                "            if (!yy_rule_cond[yy_rule][yy_start_state]) continue;"
            )?;
        }
        if has_bol_anchors {
            writeln!(
                output,
                "            if (yy_rule_bol[yy_rule] && !yy_token_at_bol) continue;"
            )?;
        }
        writeln!(output, "            yyaccept = yy_rule;")?;
        writeln!(output, "            yy_found = 1;")?;
        writeln!(output, "            break;")?;
        writeln!(output, "        }}")?;
        writeln!(output, "        if (yy_found) {{")?;
        writeln!(output, "            goto yy_execute_action;")?;
        writeln!(output, "        }}")?;
        writeln!(
            output,
            "        /* No valid rule found - do default action (ECHO one char) */"
        )?;
        writeln!(output, "        yy_at_bol = (*YYTOKEN == '\\n');")?;
        writeln!(output, "        putc(*YYTOKEN++, yyout);")?;
        writeln!(output, "        YYCURSOR = YYTOKEN;")?;
        writeln!(output, "        goto yy_scan;")?;
        writeln!(output, "    }}")?;
        writeln!(output)?;

        writeln!(output, "yy_execute_action:")?;
    }

    // Action dispatch via switch
    writeln!(output, "    /* Execute rule action */")?;
    writeln!(output, "    switch (yyaccept) {{")?;

    for (rule_idx, rule) in lexinfo.rules.iter().enumerate() {
        writeln!(output, "    case {}:", rule_idx)?;
        // Only generate yy_action_N label for the <<EOF>> rule that actually uses it
        if eof_rule_idx == Some(rule_idx) {
            writeln!(output, "    yy_action_{}:", rule_idx)?;
        }
        if rule.action.trim() == "|" {
            writeln!(output, "        /* fall through */")?;
        } else {
            writeln!(output, "        {}", rule.action)?;
            writeln!(output, "        break;")?;
        }
    }

    writeln!(output, "    default:")?;
    writeln!(output, "        ECHO;")?;
    writeln!(output, "        break;")?;
    writeln!(output, "    }}")?;
    writeln!(output)?;

    writeln!(output, "    goto yy_scan;")?;
    writeln!(output, "}}\n")?;

    // Generate yywrap and main if needed
    write_default_yywrap_main(output, lexinfo)?;

    Ok(())
}

fn write_default_yywrap_main<W: Write>(output: &mut W, lexinfo: &LexInfo) -> io::Result<()> {
    // Generate yywrap if not in user subroutines
    let has_yywrap = lexinfo.user_subs.iter().any(|s| s.contains("yywrap"));
    if !has_yywrap {
        writeln!(output, "/* Default yywrap */")?;
        writeln!(output, "int yywrap(void)")?;
        writeln!(output, "{{")?;
        writeln!(output, "    return 1;")?;
        writeln!(output, "}}")?;
        writeln!(output)?;
    }

    // Generate main if not in user subroutines
    let has_main = lexinfo
        .user_subs
        .iter()
        .any(|s| s.contains("int main") || s.contains("void main"));
    if !has_main {
        writeln!(output, "/* Default main */")?;
        writeln!(output, "#ifndef YY_SKIP_YYWRAP")?;
        writeln!(output, "int main(int argc, char *argv[])")?;
        writeln!(output, "{{")?;
        writeln!(output, "    (void)argc; (void)argv;")?;
        writeln!(output, "    return yylex();")?;
        writeln!(output, "}}")?;
        writeln!(output, "#endif\n")?;
    }

    Ok(())
}

fn write_user_subroutines<W: Write>(output: &mut W, lexinfo: &LexInfo) -> io::Result<()> {
    if !lexinfo.user_subs.is_empty() {
        writeln!(output, "/* User subroutines */")?;
        for line in &lexinfo.user_subs {
            write!(output, "{}", line)?;
        }
        writeln!(output)?;
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dfa::Dfa;
    use crate::lexfile::LexInfo;
    use crate::nfa::Nfa;
    use std::collections::HashMap;

    fn create_test_lexinfo() -> LexInfo {
        LexInfo {
            external_def: vec!["#include <stdio.h>\n".to_string()],
            subs: HashMap::new(),
            internal_defs: vec![],
            cond_start: vec![],
            cond_xstart: vec![],
            yyt_is_ptr: true,
            user_subs: vec![],
            rules: vec![],
            table_sizes: HashMap::new(),
            options: crate::lexfile::LexOptions::default(),
        }
    }

    #[test]
    fn test_generate_header() {
        let mut output = Vec::new();
        write_header(&mut output).unwrap();
        let s = String::from_utf8(output).unwrap();
        assert!(s.contains("Generated by lex-rs"));
        assert!(s.contains("Direct-coded"));
    }

    #[test]
    fn test_generate_simple_lexer() {
        let hir = regex_syntax::parse("a").unwrap();
        let nfa = Nfa::from_rules(&[(hir, 0)]).unwrap();
        let dfa = Dfa::from_nfa(&nfa);

        let mut lexinfo = create_test_lexinfo();
        lexinfo.rules.push(crate::lexfile::LexRule {
            ere: "a".to_string(),
            compiled_ere: "a".to_string(),
            action: "return 1;".to_string(),
            start_conditions: vec![],
            bol_anchor: false,
            trailing_context: None,
            compiled_trailing_context: None,
            is_eof: false,
        });

        let mut output = Vec::new();
        let config = CodeGenConfig::default();
        generate(&mut output, &dfa, &lexinfo, &config).unwrap();

        let s = String::from_utf8(output).unwrap();
        assert!(s.contains("int yylex(void)"));
        assert!(s.contains("yy_state_0:"));
        assert!(s.contains("yy_ec"));
        assert!(s.contains("YY_NUM_STATES"));
    }

    #[test]
    fn test_generate_with_bol_anchor() {
        let hir = regex_syntax::parse("foo").unwrap();
        let nfa = Nfa::from_rules(&[(hir, 0)]).unwrap();
        let dfa = Dfa::from_nfa(&nfa);

        let mut lexinfo = create_test_lexinfo();
        lexinfo.rules.push(crate::lexfile::LexRule {
            ere: "^foo".to_string(),
            compiled_ere: "foo".to_string(),
            action: "return BOL_RULE;".to_string(),
            start_conditions: vec![],
            bol_anchor: true,
            trailing_context: None,
            compiled_trailing_context: None,
            is_eof: false,
        });

        let rule_meta = vec![RuleMetadata {
            bol_anchor: true,
            main_pattern_len: None,
            has_trailing_context: false,
            has_variable_trailing_context: false,
        }];

        let mut output = Vec::new();
        let config = CodeGenConfig {
            rule_metadata: rule_meta,
            ..Default::default()
        };
        generate(&mut output, &dfa, &lexinfo, &config).unwrap();

        let s = String::from_utf8(output).unwrap();
        assert!(s.contains("return BOL_RULE"));
        assert!(s.contains("int yylex(void)"));
    }

    #[test]
    fn test_generate_with_start_conditions() {
        let hir = regex_syntax::parse("foo").unwrap();
        let nfa = Nfa::from_rules(&[(hir, 0)]).unwrap();
        let dfa = Dfa::from_nfa(&nfa);

        let mut lexinfo = create_test_lexinfo();
        lexinfo.cond_start.push("COMMENT".to_string());
        lexinfo.cond_xstart.push("STRING".to_string());
        lexinfo.rules.push(crate::lexfile::LexRule {
            ere: "foo".to_string(),
            compiled_ere: "foo".to_string(),
            action: "return 1;".to_string(),
            start_conditions: vec!["COMMENT".to_string()],
            bol_anchor: false,
            trailing_context: None,
            compiled_trailing_context: None,
            is_eof: false,
        });

        let mut output = Vec::new();
        let config = CodeGenConfig {
            start_conditions: vec![
                "INITIAL".to_string(),
                "COMMENT".to_string(),
                "STRING".to_string(),
            ],
            ..Default::default()
        };
        generate(&mut output, &dfa, &lexinfo, &config).unwrap();

        let s = String::from_utf8(output).unwrap();
        assert!(s.contains("#define INITIAL 0"));
        assert!(s.contains("#define COMMENT 1"));
        assert!(s.contains("#define STRING 2"));
        assert!(s.contains("BEGIN"));
    }

    #[test]
    fn test_generate_with_trailing_context() {
        let hir = regex_syntax::parse("foo").unwrap();
        let nfa = Nfa::from_rules(&[(hir, 0)]).unwrap();
        let dfa = Dfa::from_nfa(&nfa);

        let mut lexinfo = create_test_lexinfo();
        lexinfo.rules.push(crate::lexfile::LexRule {
            ere: "foo/bar".to_string(),
            compiled_ere: "foo".to_string(),
            action: "return TC_RULE;".to_string(),
            start_conditions: vec![],
            bol_anchor: false,
            trailing_context: Some("bar".to_string()),
            compiled_trailing_context: Some("bar".to_string()),
            is_eof: false,
        });

        let rule_meta = vec![RuleMetadata {
            bol_anchor: false,
            main_pattern_len: Some(3),
            has_trailing_context: true,
            has_variable_trailing_context: false,
        }];

        let mut output = Vec::new();
        let config = CodeGenConfig {
            rule_metadata: rule_meta,
            ..Default::default()
        };
        generate(&mut output, &dfa, &lexinfo, &config).unwrap();

        let s = String::from_utf8(output).unwrap();
        assert!(s.contains("TC_RULE"));
        assert!(s.contains("yy_rule_main_len"));
    }
}
