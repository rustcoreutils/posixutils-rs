# C99 Compliance TODO

This document tracks remaining C99 compliance items for pcc. Items are organized by priority and complexity.

## Table of Contents

- [High Priority](#high-priority)
  - [Compound Literals](#compound-literals)
  - [`__func__` Predefined Identifier](#__func__-predefined-identifier)
  - [Variable-Length Arrays (VLAs)](#variable-length-arrays-vlas)
  - [`_Complex` and `_Imaginary` Types](#_complex-and-_imaginary-types)
- [Medium Priority](#medium-priority)
  - [Array Parameter Qualifiers](#array-parameter-qualifiers)
  - [`[*]` in Function Prototypes](#-in-function-prototypes)
  - [Multi-Register Struct Returns](#multi-register-struct-returns)
  - [Universal Character Names](#universal-character-names)
- [Low Priority](#low-priority)
  - [Inline Function Optimization](#inline-function-optimization)
  - [FP Register Save for Variadic Functions](#fp-register-save-for-variadic-functions)
- [Implemented Features](#implemented-features)

---

## High Priority

These are C99 language features that are missing or broken.

### Compound Literals

**Status**: NOT IMPLEMENTED

**C99 Reference**: 6.5.2.5

**Description**: Compound literals allow creating unnamed objects with initializer syntax:
```c
struct Point p = (struct Point){1, 2};
int *arr = (int[]){1, 2, 3, 4, 5};
```

**Current Behavior**: Parse error: "unexpected token in expression"

**Location**: `cc/parse/parser.rs` lines 2208-2225

**Implementation Notes**:
- After detecting `(type)`, check if next token is `{`
- If so, parse as compound literal instead of cast
- Compound literals have automatic storage duration when in block scope
- At file scope, compound literals have static storage duration
- Add `ExprKind::CompoundLiteral { typ: TypeId, elements: Vec<InitElement> }` to AST
- Linearizer needs to allocate storage and initialize

**Complexity**: Medium

---

### `__func__` Predefined Identifier

**Status**: BROKEN

**C99 Reference**: 6.4.2.2

**Description**: Within a function body, `__func__` is implicitly declared as:
```c
static const char __func__[] = "function-name";
```

**Current Behavior**: Treated as a regular identifier lookup, generating incorrect code (references `___func__` as a global).

**Implementation Notes**:
- In the parser/linearizer, when entering a function, implicitly define `__func__`
- The value should be a string literal containing the function name
- Must have static storage duration and type `const char[]`
- Alternative: handle in linearizer by recognizing `__func__` references

**Complexity**: Low-Medium

---

### Variable-Length Arrays (VLAs)

**Status**: NOT IMPLEMENTED (parses but runtime behavior is wrong)

**C99 Reference**: 6.7.5.2

**Description**: Arrays whose size is determined at runtime:
```c
void f(int n) {
    int arr[n];  // VLA
    // ...
}
```

**Current Behavior**:
- Parser accepts VLA syntax
- Linearizer treats the size as None and allocates fixed storage
- No runtime stack adjustment occurs

**Location**:
- `cc/parse/parser.rs` lines 3409, 4061 (comments mention "Non-constant (VLA)")
- `cc/README.md` line 87

**Implementation Notes**:
1. Parser must preserve the size expression (currently discards it)
2. Linearizer must emit code to:
   - Evaluate the size expression at runtime
   - Adjust the stack pointer dynamically
   - Compute element addresses using the runtime size
3. sizeof(vla) must also be evaluated at runtime
4. VLAs cannot have initializers
5. VLAs cannot be at file scope

**Complexity**: High

---

### `_Complex` and `_Imaginary` Types

**Status**: NOT IMPLEMENTED

**C99 Reference**: 6.2.5, 6.7.2, Annex G

**Description**: Complex number types:
```c
double _Complex z = 1.0 + 2.0*I;
float _Complex w = 3.0f + 4.0fi;
```

**Current Behavior**: `_Complex` is not recognized as a keyword.

**Location**: `cc/doc/TODO.md` has detailed implementation plan

**Implementation Notes**:
- Add `COMPLEX` modifier to `TypeModifiers`
- Add `_Complex` keyword to lexer
- Complex arithmetic expansion in linearizer (real/imag operations)
- ABI considerations for parameter passing and returns
- System `<complex.h>` provides library functions

**Complexity**: High

---

## Medium Priority

### Array Parameter Qualifiers

**Status**: NOT IMPLEMENTED

**C99 Reference**: 6.7.5.3

**Description**: Qualifiers and `static` in array parameter declarations:
```c
void f(int a[const 10]);       // const-qualified array parameter
void f(int a[static 10]);      // at least 10 elements guaranteed
void f(int a[restrict]);       // restrict-qualified
void f(int a[const static 10]); // combined
```

**Current Behavior**: Parse error: "expected ']'"

**Location**: `cc/parse/parser.rs` array declarator parsing

**Implementation Notes**:
- Extend array declarator parsing to allow qualifiers after `[`
- `static` indicates minimum size (optimization hint)
- Qualifiers apply to the pointer the array decays to
- These are hints for optimization, not semantic requirements

**Complexity**: Medium

---

### `[*]` in Function Prototypes

**Status**: NOT IMPLEMENTED

**C99 Reference**: 6.7.5.2

**Description**: In function prototypes (not definitions), `[*]` indicates a VLA of unspecified size:
```c
void f(int n, int arr[*]);  // VLA parameter with unspecified size
```

**Current Behavior**: Parse error: "unexpected token in expression"

**Implementation Notes**:
- Only valid in function prototype declarations (not definitions)
- Indicates that the parameter is a VLA
- The actual size is determined by another parameter

**Complexity**: Low

---

### Multi-Register Struct Returns

**Status**: PARTIAL

**C99 Reference**: ABI-dependent (not in C99 itself)

**Description**: Structs that fit in two registers should be returned in two registers per ABI.

**Current Behavior**:
- Structs > 8 bytes use sret (hidden pointer parameter)
- Structs 9-16 bytes should use two registers but don't

**Location**:
- `cc/README.md` line 85
- `cc/target.rs` lines 99-100

**Implementation Notes**:
- x86-64 SysV: structs up to 16 bytes can be returned in RAX+RDX
- AArch64: structs up to 16 bytes can be returned in X0+X1
- Need to classify struct fields according to ABI rules
- Affects both caller and callee code generation

**Complexity**: Medium-High

---

### Universal Character Names

**Status**: NOT IMPLEMENTED

**C99 Reference**: 6.4.3

**Description**: Unicode characters in identifiers and strings:
```c
int \u00E9 = 42;           // identifier with é
char *s = "\u00E9";        // string with é
char *s = "\U0001F600";    // 32-bit UCN
```

**Current Behavior**: Not recognized (lexer treats `\u` as unknown escape)

**Implementation Notes**:
- Lexer must recognize `\uXXXX` and `\UXXXXXXXX` sequences
- Valid in identifiers (with restrictions per 6.4.2.1)
- Valid in character constants and string literals
- Convert to UTF-8 in output

**Complexity**: Medium

---

## Low Priority

These items are implemented but incomplete or have known limitations that rarely affect real code.

### Inline Function Optimization

**Status**: PARTIAL (semantics correct, optimization missing)

**C99 Reference**: 6.7.4

**Description**: The `inline` keyword is a hint for inlining.

**Current Behavior**:
- `inline` keyword is recognized and parsed
- C99 inline semantics are correctly enforced (restrictions on static references)
- Functions are NOT actually inlined

**Location**:
- `cc/README.md` line 84
- `cc/ir/linearize.rs` lines 725-739 (semantic checks)

**Impact**: Performance only; no correctness issues.

**Complexity**: High (requires inlining pass in optimizer)

---

### FP Register Save for Variadic Functions

**Status**: PARTIAL

**C99 Reference**: ABI-dependent

**Description**: On x86-64 SysV ABI, variadic functions should save XMM registers for floating-point variadic arguments.

**Current Behavior**:
- GP registers are saved correctly
- XMM registers are not saved
- `va_arg(ap, double)` in user-defined variadic functions won't work

**Location**: `cc/doc/TODO.md` lines 49-69

**Impact**: Low. libc variadic functions work correctly. Only affects user-defined variadic functions accepting float/double arguments.

**Complexity**: Medium

---

## Implemented Features

The following C99 features are fully implemented:

### Types
- `_Bool` type
- `long long` integer type
- All integer and floating-point types
- Type qualifiers: `const`, `volatile`, `restrict`
- Flexible array members (`struct { int n; char data[]; }`)

### Literals
- Hexadecimal floating-point literals (`0x1.0p10`)
- Long long integer suffixes (`LL`, `ULL`)
- Wide character/string literals (`L'x'`, `L"string"`)

### Declarations
- Mixed declarations and statements
- Declarations in `for` loop initializers (`for (int i = 0; ...)`)
- Designated initializers (`.field = value`, `[index] = value`)
- Inline function specifier (keyword recognized, semantics enforced)
- Static storage class with linkage rules

### Expressions
- Compound assignment operators
- `sizeof` on expressions and types

### Statements
- All control flow statements

### Preprocessor
- Variadic macros (`__VA_ARGS__`)
- `#error` and `#warning` directives
- `#line` directive
- `#pragma once`
- `_Pragma` operator (not tested)
- Predefined macros: `__STDC__`, `__STDC_VERSION__`, `__STDC_HOSTED__`, etc.

### Other
- `//` single-line comments
- Empty macro arguments
- Trailing comma in enum definitions

---

## Summary Table

| Feature | Status | Complexity | Priority |
|---------|--------|------------|----------|
| Compound literals | Not implemented | Medium | High |
| `__func__` | Broken | Low-Medium | High |
| VLAs (runtime) | Not implemented | High | High |
| `_Complex` / `_Imaginary` | Not implemented | High | High |
| Array parameter qualifiers | Not implemented | Medium | Medium |
| `[*]` in prototypes | Not implemented | Low | Medium |
| Multi-register struct returns | Partial | Medium-High | Medium |
| Universal character names | Not implemented | Medium | Medium |
| Inline optimization | Not implemented | High | Low |
| FP variadic save | Not implemented | Medium | Low |

---

## References

- [ISO/IEC 9899:1999 (C99)](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf)
- [C99 Rationale](https://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf)
- [cppreference C99 features](https://en.cppreference.com/w/c/99)
