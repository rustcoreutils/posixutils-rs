//
// Copyright (c) 2025-2026 Jeff Garzik
//
// This file is part of the posixutils-rs project covered under
// the MIT License.  For the full license text, please see the LICENSE
// file in the root directory of this project.
// SPDX-License-Identifier: MIT
//
// Architecture-independent code generation interface
//

use crate::ir::{Function, Module, Opcode};
use crate::target::Target;
use crate::types::TypeTable;

// ============================================================================
// Shared Helper Types
// ============================================================================

/// Unary integer operation type
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UnaryOp {
    Neg,
    Not,
}

/// Byte-swap size
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BswapSize {
    B16,
    B32,
    B64,
}

// ============================================================================
// Constants
// ============================================================================

/// pcc version string for assembly header
pub const PCC_VERSION: &str = env!("CARGO_PKG_VERSION");

/// Generate header comment lines for assembly output (GCC-style)
/// Returns a vector of comment strings to be emitted
pub fn generate_header_comments(target: &Target) -> Vec<String> {
    let mut comments = Vec::new();

    // Target triple (normalized format)
    let os_triple = match target.os {
        crate::target::Os::Linux => "unknown-linux-gnu",
        crate::target::Os::MacOS => "apple-darwin",
        crate::target::Os::FreeBSD => "unknown-freebsd",
    };

    // Compiler identification with target
    comments.push(format!(
        "Generated by pcc {} ({}-{})",
        PCC_VERSION, target.arch, os_triple
    ));

    comments
}

/// Check if a function uses variadic arguments (contains VaStart opcode)
pub fn is_variadic_function(func: &Function) -> bool {
    for block in &func.blocks {
        for insn in &block.insns {
            if matches!(insn.op, Opcode::VaStart) {
                return true;
            }
        }
    }
    false
}

/// Escape a string for assembly output (.ascii/.asciz directives)
/// Non-printable and non-ASCII characters are escaped as octal byte sequences.
pub fn escape_string(s: &str) -> String {
    let mut result = String::new();
    for c in s.chars() {
        match c {
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            '\\' => result.push_str("\\\\"),
            '"' => result.push_str("\\\""),
            c if c.is_ascii_graphic() || c == ' ' => result.push(c),
            c => {
                // Escape non-printable as octal bytes (handles UTF-8 correctly)
                for byte in c.to_string().as_bytes() {
                    result.push_str(&format!("\\{:03o}", byte));
                }
            }
        }
    }
    result
}

/// Trait for architecture-specific code generators
pub trait CodeGenerator {
    /// Generate assembly code for the given IR module
    fn generate(&mut self, module: &Module, types: &TypeTable) -> String;

    /// Set whether to emit basic unwind tables (cfi_startproc/cfi_endproc)
    fn set_emit_unwind_tables(&mut self, emit: bool);
}

/// Create a code generator for the given target with options
pub fn create_codegen_with_options(
    target: Target,
    emit_unwind_tables: bool,
) -> Box<dyn CodeGenerator> {
    use crate::target::Arch;

    let mut codegen: Box<dyn CodeGenerator> = match target.arch {
        Arch::X86_64 => Box::new(super::x86_64::codegen::X86_64CodeGen::new(target)),
        Arch::Aarch64 => Box::new(super::aarch64::codegen::Aarch64CodeGen::new(target)),
    };
    codegen.set_emit_unwind_tables(emit_unwind_tables);
    codegen
}
