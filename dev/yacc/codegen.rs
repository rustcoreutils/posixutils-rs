//
// Copyright (c) 2025-2026 Jeff Garzik
//
// This file is part of the posixutils-rs project covered under
// the MIT License.  For the full license text, please see the LICENSE
// file in the root directory of this project.
// SPDX-License-Identifier: MIT
//

//! C code generation for the yacc parser.
//!
//! Generates a complete C parser from LALR(1) tables. Output includes:
//! - Token defines and YYSTYPE union
//! - Dense parse tables (action/goto indexed by state Ã— symbol)
//! - Stack-based parser with error recovery per POSIX

use crate::diag;
use crate::error::YaccError;
use crate::grammar::{Grammar, EOF_SYMBOL, ERROR_SYMBOL};
use crate::lalr::{Action, LALRAutomaton};
use crate::Options;
use std::collections::BTreeMap;
use std::fs::File;
use std::io::{BufWriter, Write};

/// Packed/optimized parse tables for code generation and verification.
///
/// Uses dense terminal/non-terminal numbering for direct array indexing:
/// - action[state * num_terminals + term_idx] for ACTION table
/// - goto[state * num_nonterminals + nt_idx] for GOTO table
///
/// Per POSIX: "A parser generated by yacc shall never request an input symbol
/// from yylex() while in a state where the only actions other than the error
/// action are reductions by a single rule." (consistent state optimization)
#[derive(Debug)]
pub struct PackedTables {
    /// Dense action table indexed by: state * num_terminals + term_idx
    /// Values: >0 = shift to state, <0 = reduce by (-(value+1)), 0 = accept/error,
    /// i16::MIN = explicit error (%nonassoc)
    pub action: Vec<i16>,
    /// Dense goto table indexed by: state * num_nonterminals + nt_idx
    /// Values: >=0 = target state, -1 = use defgoto
    pub goto: Vec<i16>,
    /// Default reduction for each state (production_id + 1, or 0 for none)
    pub defact: Vec<u16>,
    /// Default goto for each nonterminal
    pub defgoto: Vec<i16>,
    /// Consistent states: true if only one reduce action exists (no shifts)
    pub consistent: Vec<bool>,
    /// Number of parser states
    pub num_states: usize,
    /// Number of terminals (for table indexing)
    pub num_terminals: usize,
    /// Number of non-terminals (for table indexing)
    pub num_nonterminals: usize,
}

/// Generate output files
pub fn generate(opts: &Options, grammar: &Grammar, lalr: &LALRAutomaton) -> Result<(), YaccError> {
    // Generate description file first if requested (per POSIX, should be produced even on errors)
    if opts.write_description {
        let desc_path = format!("{}.output", opts.file_prefix);
        generate_description_file(&desc_path, grammar, lalr)?;
    }

    // Generate code file
    let code_path = format!("{}.tab.c", opts.file_prefix);
    generate_code_file(&code_path, opts, grammar, lalr)?;

    // Generate header file if requested
    if opts.write_header {
        let header_path = format!("{}.tab.h", opts.file_prefix);
        generate_header_file(&header_path, opts, grammar)?;
    }

    Ok(())
}

/// Generate the main code file (y.tab.c)
fn generate_code_file(
    path: &str,
    opts: &Options,
    grammar: &Grammar,
    lalr: &LALRAutomaton,
) -> Result<(), YaccError> {
    let file = File::create(path)
        .map_err(|e| YaccError::Io(format!("cannot create '{}': {}", path, e)))?;
    let mut w = BufWriter::new(file);

    // Header comments
    writeln!(
        w,
        "/* A POSIX yacc parser, generated by yacc from posixutils-rs v{}.  */",
        env!("CARGO_PKG_VERSION")
    )?;
    writeln!(w)?;

    // YYDEBUG definition
    if opts.debug_enabled {
        writeln!(
            w,
            r#"#ifndef YYDEBUG
# define YYDEBUG 1
#endif
"#
        )?;
    } else {
        writeln!(
            w,
            r#"#ifndef YYDEBUG
# define YYDEBUG 0
#endif
"#
        )?;
    }

    // Standard includes
    writeln!(
        w,
        r#"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
"#
    )?;

    // Prologue code
    for code_block in &grammar.prologue {
        if !opts.omit_line_directives {
            writeln!(w, "#line {} \"{}\"", code_block.line, opts.grammar_file)?;
        }
        writeln!(w, "{}", code_block.code)?;
    }
    writeln!(w)?;

    // Token definitions
    generate_token_defines(&mut w, grammar, opts)?;
    writeln!(w)?;

    // YYSTYPE definition
    if let Some(ref union_def) = grammar.union_def {
        writeln!(w, "#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED")?;
        if !opts.omit_line_directives {
            writeln!(w, "#line {} \"{}\"", union_def.line, opts.grammar_file)?;
        }
        writeln!(w, "typedef union YYSTYPE")?;
        writeln!(w, "{}", union_def.code)?;
        writeln!(w, " YYSTYPE;")?;
        writeln!(w, "# define YYSTYPE_IS_DECLARED 1")?;
        writeln!(w, "#endif")?;
    } else {
        writeln!(
            w,
            r#"#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_DECLARED 1
#endif
"#
        )?;
    }

    // External declarations
    let prefix = &opts.sym_prefix;
    writeln!(w, "/* External declarations */")?;
    writeln!(w, "extern YYSTYPE {}lval;", prefix)?;
    writeln!(w, "extern int {}char;", prefix)?;
    writeln!(w, "extern int {}nerrs;", prefix)?;
    writeln!(w)?;

    // Function declarations
    writeln!(w, "/* Function declarations */")?;
    writeln!(w, "int {}lex(void);", prefix)?;
    writeln!(w, "void {}error(const char *s);", prefix)?;
    writeln!(w)?;

    // Parser tables
    generate_tables(&mut w, grammar, lalr, opts)?;

    // Parser implementation
    generate_parser(&mut w, grammar, lalr, opts)?;

    // Epilogue code
    if let Some(ref epilogue) = grammar.epilogue {
        if !opts.omit_line_directives {
            writeln!(w, "#line {} \"{}\"", epilogue.line, opts.grammar_file)?;
        }
        writeln!(w, "{}", epilogue.code)?;
    }

    w.flush()
        .map_err(|e| YaccError::Io(format!("error writing '{}': {}", path, e)))?;

    Ok(())
}

/// Generate token #define statements
fn generate_token_defines<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    opts: &Options,
) -> Result<(), YaccError> {
    writeln!(w, "/* Token definitions */")?;

    // Collect tokens that need #define (exclude char literals and special tokens)
    let mut tokens: Vec<(String, i32)> = Vec::new();

    for (id, sym) in grammar.symbols.iter().enumerate() {
        if sym.is_terminal && id != EOF_SYMBOL && id != ERROR_SYMBOL {
            if let Some(num) = sym.token_number {
                // Skip character literals (they don't need defines)
                if !sym.name.starts_with('\'') {
                    // Check if name is a valid C identifier
                    if is_valid_c_identifier(&sym.name) {
                        tokens.push((sym.name.clone(), num));
                    }
                }
            }
        }
    }

    // Sort by token number for consistent output
    tokens.sort_by_key(|(_, n)| *n);

    for (name, num) in &tokens {
        let prefixed_name = if opts.sym_prefix != "yy" {
            format!("{}_{}", opts.sym_prefix.to_uppercase(), name)
        } else {
            name.clone()
        };
        writeln!(w, "#define {} {}", prefixed_name, num)?;
    }

    Ok(())
}

/// Check if a name is a valid C identifier
fn is_valid_c_identifier(name: &str) -> bool {
    let mut chars = name.chars();
    match chars.next() {
        Some(c) if c.is_alphabetic() || c == '_' => {}
        _ => return false,
    }
    chars.all(|c| c.is_alphanumeric() || c == '_')
}

/// Generate parsing tables: token translation, rule info, action/goto, debug.
fn generate_tables<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    lalr: &LALRAutomaton,
    opts: &Options,
) -> Result<(), YaccError> {
    let prefix = &opts.sym_prefix;
    let num_states = lalr.lr0.states.len();

    writeln!(w, "/* Parser tables */")?;
    writeln!(w)?;

    // YYFINAL - the accepting state
    let final_state = find_final_state(lalr);
    writeln!(w, "#define YYFINAL {}", final_state)?;
    writeln!(w)?;

    // YYNTOKENS - number of terminals
    writeln!(w, "#define YYNTOKENS {}", grammar.num_terminals)?;
    writeln!(w)?;

    // YYNNTS - number of non-terminals
    writeln!(w, "#define YYNNTS {}", grammar.num_nonterminals)?;
    writeln!(w)?;

    // YYERROR_TERM_IDX - dense terminal index for the error token
    let error_term_idx = grammar
        .terminal_index(ERROR_SYMBOL)
        .expect("error must have term_idx");
    writeln!(w, "#define YYERROR_TERM_IDX {}", error_term_idx)?;
    writeln!(w)?;

    // YYNRULES - number of rules
    writeln!(w, "#define YYNRULES {}", grammar.productions.len())?;
    writeln!(w)?;

    // YYNSTATES - number of states
    writeln!(w, "#define YYNSTATES {}", num_states)?;
    writeln!(w)?;

    // YYTABLE_NINF - sentinel value for explicit error actions (%nonassoc conflicts)
    writeln!(w, "#define YYTABLE_NINF (-32768)")?;
    writeln!(w)?;

    // Token translation table
    generate_token_translate_table(w, grammar, prefix)?;

    // Rule info tables
    generate_rule_tables(w, grammar, prefix)?;

    // ACTION and GOTO tables in compressed format
    generate_action_goto_tables(w, grammar, lalr, prefix, opts.strict_mode)?;

    // Debug tables (only when debug is enabled)
    if opts.debug_enabled {
        generate_debug_tables(w, grammar, prefix)?;
    }

    Ok(())
}

/// Find the accepting state
fn find_final_state(lalr: &LALRAutomaton) -> usize {
    // The accepting state is where we accept on EOF
    for (state_id, actions) in lalr.action_table.iter().enumerate() {
        if let Some(Action::Accept) = actions.get(&EOF_SYMBOL) {
            return state_id;
        }
    }
    1 // Default fallback
}

/// Generate token translation table.
///
/// Maps external token numbers (from yylex) to dense terminal indices (0..YYNTOKENS-1).
/// This enables direct indexing into the dense action table.
fn generate_token_translate_table<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    prefix: &str,
) -> Result<(), YaccError> {
    // Find max token number to determine table size
    let max_token = grammar
        .symbols
        .iter()
        .filter_map(|s| s.token_number)
        .max()
        .unwrap_or(256);

    // Get dense indices for special tokens
    let eof_term_idx = grammar
        .terminal_index(EOF_SYMBOL)
        .expect("EOF must have term_idx");
    let error_term_idx = grammar
        .terminal_index(ERROR_SYMBOL)
        .expect("error must have term_idx");

    writeln!(w, "/* Token number -> dense terminal index */")?;
    writeln!(w, "static const unsigned short {}translate[] =", prefix)?;
    writeln!(w, "{{")?;

    // Create translation: external token number -> dense terminal index
    // Unknown tokens map to error_term_idx (the error token's dense index)
    let mut translate = vec![error_term_idx as u16; (max_token + 1) as usize];
    translate[0] = eof_term_idx as u16; // EOF token number 0 -> EOF dense index

    for (sym_id, sym) in grammar.symbols.iter().enumerate() {
        if sym.is_terminal {
            if let Some(num) = sym.token_number {
                if num >= 0 && (num as usize) < translate.len() {
                    if let Some(term_idx) = grammar.terminal_index(sym_id) {
                        translate[num as usize] = term_idx as u16;
                    }
                }
            }
        }
    }

    // Write table in rows of 16
    for (i, chunk) in translate.chunks(16).enumerate() {
        write!(w, "    ")?;
        for (j, &val) in chunk.iter().enumerate() {
            if i * 16 + j > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:3}", val)?;
        }
        writeln!(w)?;
    }

    writeln!(w, "}};")?;
    writeln!(w)?;

    Ok(())
}

/// Generate rule info tables
fn generate_rule_tables<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    prefix: &str,
) -> Result<(), YaccError> {
    // Build mapping from raw symbol ID to internal symbol number
    // Non-terminals should be numbered starting at num_terminals (YYNTOKENS)
    // so that the parser can compute: nt_idx = yylhs - YYNTOKENS
    let mut symbol_to_internal: std::collections::HashMap<usize, usize> =
        std::collections::HashMap::new();
    for (nt_idx, nt_id) in grammar.nonterminals().enumerate() {
        symbol_to_internal.insert(nt_id, grammar.num_terminals + nt_idx);
    }

    // yyr1 - LHS symbol of each rule (using internal symbol numbers)
    writeln!(w, "/* LHS symbol of each rule */")?;
    writeln!(w, "static const unsigned short {}r1[] =", prefix)?;
    writeln!(w, "{{")?;
    write!(w, "    ")?;
    for (i, prod) in grammar.productions.iter().enumerate() {
        if i > 0 {
            write!(w, ",")?;
        }
        // Convert raw symbol ID to internal symbol number
        let internal_sym = symbol_to_internal
            .get(&prod.lhs)
            .copied()
            .unwrap_or(prod.lhs);
        write!(w, "{:3}", internal_sym)?;
    }
    writeln!(w)?;
    writeln!(w, "}};")?;
    writeln!(w)?;

    // yyr2 - Number of symbols on RHS of each rule
    writeln!(w, "/* Number of symbols on RHS of each rule */")?;
    writeln!(w, "static const unsigned char {}r2[] =", prefix)?;
    writeln!(w, "{{")?;
    write!(w, "    ")?;
    for (i, prod) in grammar.productions.iter().enumerate() {
        if i > 0 {
            write!(w, ",")?;
        }
        write!(w, "{:3}", prod.rhs.len())?;
    }
    writeln!(w)?;
    writeln!(w, "}};")?;
    writeln!(w)?;

    Ok(())
}

/// Generate ACTION and GOTO tables using dense numbering.
///
/// Outputs dense tables for direct array indexing:
/// - yyaction[state * YYNTOKENS + term_idx]
/// - yygoto[state * YYNNTS + nt_idx]
fn generate_action_goto_tables<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    lalr: &LALRAutomaton,
    prefix: &str,
    strict_mode: bool,
) -> Result<(), YaccError> {
    let num_states = lalr.action_table.len();

    // Compute default actions (most common action per state)
    let mut default_action: Vec<i16> = vec![0; num_states];
    for (state_id, actions) in lalr.action_table.iter().enumerate() {
        // Find most common reduce action
        let mut reduce_counts: BTreeMap<i16, usize> = BTreeMap::new();
        for action in actions.values() {
            if let Action::Reduce(prod_id) = action {
                *reduce_counts.entry(-(*prod_id as i16) - 1).or_insert(0) += 1;
            }
        }
        if let Some((&action, _)) = reduce_counts.iter().max_by_key(|(_, &count)| count) {
            default_action[state_id] = action;
        }
    }

    // Build packed tables with dense indexing
    let packed = build_packed_tables(grammar, lalr, &default_action, strict_mode);

    // Formal verification: ensure packed tables match canonical tables exactly
    // This runs on every invocation and panics on any mismatch (internal bug)
    crate::verify::verify_tables(grammar, lalr, &packed);

    write_c_table(
        w,
        "Default reduction for each state",
        "unsigned short",
        "defact",
        prefix,
        &packed.defact,
        3,
        |v| format!("{}", v),
    )?;

    write_c_table(
        w,
        "Consistent states (skip lookahead) - POSIX optimization",
        "unsigned char",
        "consistent",
        prefix,
        &packed.consistent,
        3,
        |v| format!("{}", if *v { 1 } else { 0 }),
    )?;

    write_c_table(
        w,
        "Default goto for each non-terminal",
        "short",
        "defgoto",
        prefix,
        &packed.defgoto,
        5,
        |v| format!("{}", v),
    )?;

    write_c_table(
        w,
        "Dense action table: action[state * YYNTOKENS + term_idx]",
        "short",
        "action",
        prefix,
        &packed.action,
        5,
        |v| format!("{}", v),
    )?;

    write_c_table(
        w,
        "Dense goto table: goto[state * YYNNTS + nt_idx]",
        "short",
        "goto",
        prefix,
        &packed.goto,
        5,
        |v| format!("{}", v),
    )?;

    Ok(())
}

/// Build packed tables using dense terminal/non-terminal numbering.
///
/// This creates dense action and goto tables for direct array indexing:
/// - action[state * num_terminals + term_idx]
/// - goto[state * num_nonterminals + nt_idx]
fn build_packed_tables(
    grammar: &Grammar,
    lalr: &LALRAutomaton,
    _default_action: &[i16],
    strict_mode: bool,
) -> PackedTables {
    let num_states = lalr.action_table.len();
    let num_terminals = grammar.num_terminals;
    let num_nonterminals = grammar.num_nonterminals;

    // Allocate dense action table: state * num_terminals + term_idx
    // Default value 0 means "consult defact" (or error if defact is also 0)
    let action_size = num_states * num_terminals;
    let mut action = vec![0i16; action_size.max(1)];

    // Allocate dense goto table: state * num_nonterminals + nt_idx
    // Default value -1 means "consult defgoto"
    let goto_size = num_states * num_nonterminals;
    let mut goto = vec![-1i16; goto_size.max(1)];

    let mut defact = vec![0u16; num_states];
    let mut defgoto = vec![-1i16; num_nonterminals.max(1)];
    // Per POSIX: track states where only one reduce action exists (no shifts)
    // so the parser can skip calling yylex() in those states
    // In strict mode, disable this optimization to preserve exact yylex timing
    let mut consistent = vec![false; num_states];

    // Fill action table using dense terminal indices
    for (state_id, actions) in lalr.action_table.iter().enumerate() {
        // Find default reduction and check if state is "consistent"
        // A state is consistent if:
        // - It has no shift actions (only reduces and/or error)
        // - All reduce actions reduce by the same rule
        let mut best_reduce: Option<usize> = None;
        let mut best_count = 0;
        let mut has_shift = false;
        let mut all_same_reduce = true;
        let mut first_reduce: Option<usize> = None;

        for action_val in actions.values() {
            match action_val {
                Action::Shift(_) | Action::Accept => {
                    has_shift = true;
                }
                Action::Reduce(prod_id) => {
                    let count = actions
                        .values()
                        .filter(|a| matches!(a, Action::Reduce(p) if p == prod_id))
                        .count();
                    if count > best_count {
                        best_count = count;
                        best_reduce = Some(*prod_id);
                    }
                    // Check if all reduces are by the same rule
                    match first_reduce {
                        None => first_reduce = Some(*prod_id),
                        Some(first) if first != *prod_id => all_same_reduce = false,
                        _ => {}
                    }
                }
                Action::Error => {}
            }
        }

        // Store production_id + 1 so that 0 means "no default action"
        defact[state_id] = match best_reduce {
            Some(prod_id) => (prod_id + 1) as u16,
            None => 0,
        };

        // State is consistent if no shifts and all reduces are by same rule
        // In strict mode, disable this optimization to preserve exact yylex timing
        if !strict_mode {
            consistent[state_id] = !has_shift && all_same_reduce && best_reduce.is_some();
        }

        // Fill action entries using dense terminal index
        // Skip Accept - handled by YYFINAL special case, not table lookup
        for (&symbol, action_val) in actions {
            if matches!(action_val, Action::Accept) {
                continue;
            }
            if let Some(term_idx) = grammar.terminal_index(symbol) {
                let idx = state_id * num_terminals + term_idx;
                action[idx] = action_to_value(action_val);
            }
        }
    }

    // Fill goto table using dense non-terminal indices
    for (nt_idx, nt_id) in grammar.nt_idx_to_symbol.iter().enumerate() {
        // Find default goto (most common target state)
        let mut goto_counts: BTreeMap<i16, usize> = BTreeMap::new();
        for (state_id, gotos) in lalr.goto_table.iter().enumerate() {
            if let Some(&target) = gotos.get(nt_id) {
                *goto_counts.entry(target as i16).or_insert(0) += 1;

                // Fill goto table entry: goto[state * num_nonterminals + nt_idx]
                let idx = state_id * num_nonterminals + nt_idx;
                goto[idx] = target as i16;
            }
        }

        // Set defgoto to most common target
        if let Some((&target, _)) = goto_counts.iter().max_by_key(|(_, &count)| count) {
            if nt_idx < defgoto.len() {
                defgoto[nt_idx] = target;
            }
        }
    }

    PackedTables {
        action,
        goto,
        defact,
        defgoto,
        consistent,
        num_states,
        num_terminals,
        num_nonterminals,
    }
}

/// Convert action to table value: >0=shift, <0=reduce, 0=accept/default, MIN=error.
fn action_to_value(action: &Action) -> i16 {
    match action {
        Action::Shift(state) => *state as i16,
        Action::Reduce(prod) => -((*prod as i16) + 1),
        Action::Accept => 0,
        Action::Error => i16::MIN,
    }
}

/// Write a C array table with consistent formatting.
fn write_c_table<W: Write, T, F>(
    w: &mut W,
    comment: &str,
    c_type: &str,
    name: &str,
    prefix: &str,
    data: &[T],
    width: usize,
    format_val: F,
) -> Result<(), YaccError>
where
    F: Fn(&T) -> String,
{
    writeln!(w, "/* {} */", comment)?;
    writeln!(w, "static const {} {}{}[] =", c_type, prefix, name)?;
    writeln!(w, "{{")?;
    for chunk in data.chunks(10) {
        write!(w, "    ")?;
        for (i, val) in chunk.iter().enumerate() {
            if i > 0 {
                write!(w, ",")?;
            }
            write!(w, "{:>width$}", format_val(val), width = width)?;
        }
        writeln!(w, ",")?;
    }
    writeln!(w, "}};")?;
    writeln!(w)?;
    Ok(())
}

/// Generate debugging tables (token names and rule descriptions)
fn generate_debug_tables<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    prefix: &str,
) -> Result<(), YaccError> {
    writeln!(w, "#if YYDEBUG")?;
    writeln!(w)?;

    // Token name table - maps internal symbol ID to printable name
    writeln!(w, "/* Symbol names for debugging */")?;
    writeln!(w, "static const char *const {}tname[] =", prefix)?;
    writeln!(w, "{{")?;

    for (id, sym) in grammar.symbols.iter().enumerate() {
        let name = &sym.name;
        // Escape special characters in name for C string
        let escaped = escape_c_string(name);
        if id > 0 {
            writeln!(w, ",")?;
        }
        write!(w, "    \"{}\"", escaped)?;
    }
    writeln!(w)?;
    writeln!(w, "}};")?;
    writeln!(w)?;

    // Rule descriptions - human-readable form of each rule
    writeln!(w, "/* Rule descriptions for debugging */")?;
    writeln!(w, "static const char *const {}rule[] =", prefix)?;
    writeln!(w, "{{")?;

    for (id, prod) in grammar.productions.iter().enumerate() {
        let lhs_name = grammar.symbol_name(prod.lhs);
        let mut rhs_str = String::new();
        for &sym_id in &prod.rhs {
            if !rhs_str.is_empty() {
                rhs_str.push(' ');
            }
            rhs_str.push_str(grammar.symbol_name(sym_id));
        }
        if rhs_str.is_empty() {
            rhs_str = "/* empty */".to_string();
        }

        let rule_str = format!("{} -> {}", lhs_name, rhs_str);
        let escaped = escape_c_string(&rule_str);

        if id > 0 {
            writeln!(w, ",")?;
        }
        write!(w, "    \"{}\"", escaped)?;
    }
    writeln!(w)?;
    writeln!(w, "}};")?;
    writeln!(w)?;

    writeln!(w, "#endif /* YYDEBUG */")?;
    writeln!(w)?;

    Ok(())
}

/// Get the translate table size (max token number + 1)
fn get_translate_table_size(grammar: &Grammar) -> usize {
    let max_token = grammar
        .symbols
        .iter()
        .filter_map(|s| s.token_number)
        .max()
        .unwrap_or(256);
    (max_token + 1) as usize
}

/// Escape a string for use in a C string literal
fn escape_c_string(s: &str) -> String {
    let mut result = String::new();
    for c in s.chars() {
        match c {
            '\\' => result.push_str("\\\\"),
            '"' => result.push_str("\\\""),
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            c if c.is_ascii_control() => {
                result.push_str(&format!("\\{:03o}", c as u8));
            }
            c => result.push(c),
        }
    }
    result
}

/// Generate parser implementation (yyparse function).
///
/// Emits a shift-reduce parser with:
/// - Hybrid stack allocation (C stack initially, heap on overflow)
/// - POSIX consistent-state optimization (skip yylex when only reduce possible)
/// - Three-phase error recovery (per POSIX errflag protocol)
fn generate_parser<W: Write>(
    w: &mut W,
    grammar: &Grammar,
    _lalr: &LALRAutomaton,
    opts: &Options,
) -> Result<(), YaccError> {
    let prefix = &opts.sym_prefix;

    writeln!(w, "/* Parser implementation */")?;
    writeln!(w)?;

    // Global variables
    writeln!(w, "YYSTYPE {}lval;", prefix)?;
    writeln!(w, "int {}char;", prefix)?;
    writeln!(w, "int {}nerrs;", prefix)?;
    writeln!(w)?;

    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "int {}debug = 0;", prefix)?;
        writeln!(w, "#endif")?;
        writeln!(w)?;
    }

    // Stack size
    writeln!(
        w,
        r#"#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Branch prediction hints for performance */
#if defined(__has_builtin) && __has_builtin(__builtin_expect)
#define YYLIKELY(x)   __builtin_expect(!!(x), 1)
#define YYUNLIKELY(x) __builtin_expect(!!(x), 0)
#elif defined(__GNUC__) && !defined(__clang__)
/* Older GCC without __has_builtin still has __builtin_expect */
#define YYLIKELY(x)   __builtin_expect(!!(x), 1)
#define YYUNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#define YYLIKELY(x)   (x)
#define YYUNLIKELY(x) (x)
#endif
"#
    )?;

    // Error handling macros (POSIX required)
    writeln!(
        w,
        "/* YYERROR - trigger error handling from semantic action */"
    )?;
    writeln!(w, "#define YYERROR goto {}errlab1", prefix)?;
    writeln!(w)?;
    writeln!(w, "/* YYACCEPT - return successfully from yyparse */")?;
    writeln!(w, "#define YYACCEPT goto {}acceptlab", prefix)?;
    writeln!(w)?;
    writeln!(w, "/* YYABORT - return with failure from yyparse */")?;
    writeln!(w, "#define YYABORT goto {}abortlab", prefix)?;
    writeln!(w)?;
    writeln!(w, "/* yyerrok - signal that error recovery is complete */")?;
    writeln!(w, "#define yyerrok ({}errflag = 0)", prefix)?;
    writeln!(w)?;
    writeln!(w, "/* yyclearin - discard lookahead token */")?;
    writeln!(w, "#define yyclearin ({}char = -1)", prefix)?;
    writeln!(w)?;
    writeln!(
        w,
        "/* YYRECOVERING - nonzero if recovering from syntax error */"
    )?;
    writeln!(w, "#define YYRECOVERING() ({}errflag != 0)", prefix)?;
    writeln!(w)?;

    // yyparse function
    writeln!(w, "int")?;
    writeln!(w, "{}parse(void)", prefix)?;
    writeln!(w, "{{")?;

    // Local variables
    writeln!(w, "    int {}state;", prefix)?;
    writeln!(w, "    int {}n;", prefix)?;
    writeln!(w, "    int {}result;", prefix)?;
    writeln!(
        w,
        "    int {}errflag = 0;  /* error recovery counter: 0=none, 1-3=recovering */",
        prefix
    )?;
    writeln!(w)?;

    // Stacks - use hybrid allocation: start on C stack, migrate to heap if needed
    writeln!(w, "    /* Initial stack arrays (on C stack for speed) */")?;
    writeln!(w, "    int {}ssa[YYINITDEPTH];", prefix)?;
    writeln!(w, "    YYSTYPE {}vsa[YYINITDEPTH];", prefix)?;
    writeln!(w)?;

    writeln!(w, "    /* State stack */")?;
    writeln!(w, "    int {}ssp_offset;", prefix)?;
    writeln!(w, "    int *{}ss = {}ssa;", prefix, prefix)?;
    writeln!(w, "    int *{}sslim;", prefix)?;
    writeln!(w, "    int {}stacksize = YYINITDEPTH;", prefix)?;
    writeln!(w)?;

    writeln!(w, "    /* Value stack */")?;
    writeln!(w, "    YYSTYPE *{}vs = {}vsa;", prefix, prefix)?;
    writeln!(w, "    YYSTYPE *{}vsp;", prefix)?;
    writeln!(w, "    YYSTYPE {}val = {{0}};", prefix)?;
    writeln!(w)?;

    writeln!(w, "    {}ssp_offset = 0;", prefix)?;
    writeln!(w, "    {}vsp = {}vs;", prefix, prefix)?;
    writeln!(
        w,
        "    {}sslim = {}ss + {}stacksize - 1;",
        prefix, prefix, prefix
    )?;
    writeln!(w)?;

    // Initialize
    writeln!(w, "    {}state = 0;", prefix)?;
    writeln!(w, "    {}char = -1;", prefix)?;
    writeln!(w, "    {}nerrs = 0;", prefix)?;
    writeln!(w)?;

    writeln!(w, "{}newstate:", prefix)?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "    if ({}debug)", prefix)?;
        writeln!(
            w,
            "        fprintf(stderr, \"Entering state %d\\n\", {}state);",
            prefix
        )?;
        writeln!(w, "#endif")?;
    }
    writeln!(
        w,
        "    {}ss[{}ssp_offset] = {}state;",
        prefix, prefix, prefix
    )?;
    writeln!(w)?;

    // Check for stack overflow - use hybrid allocation strategy
    writeln!(
        w,
        "    if ({}ss + {}ssp_offset >= {}sslim) {{",
        prefix, prefix, prefix
    )?;
    writeln!(w, "        int new_size = {}stacksize * 2;", prefix)?;
    writeln!(
        w,
        "        if (new_size > YYMAXDEPTH) new_size = YYMAXDEPTH;"
    )?;
    writeln!(
        w,
        "        if (new_size <= {}stacksize) goto {}exhausted;",
        prefix, prefix
    )?;
    writeln!(w)?;
    // Check if we're still using the stack-allocated arrays
    writeln!(w, "        if ({}ss == {}ssa) {{", prefix, prefix)?;
    writeln!(
        w,
        "            /* First overflow: migrate from C stack to heap */"
    )?;
    writeln!(
        w,
        "            int *new_ss = (int *) malloc(new_size * sizeof(int));"
    )?;
    writeln!(
        w,
        "            YYSTYPE *new_vs = (YYSTYPE *) malloc(new_size * sizeof(YYSTYPE));"
    )?;
    writeln!(w, "            if (!new_ss || !new_vs) {{")?;
    writeln!(w, "                free(new_ss);")?;
    writeln!(w, "                goto {}exhausted;", prefix)?;
    writeln!(w, "            }}")?;
    writeln!(
        w,
        "            memcpy(new_ss, {}ss, {}stacksize * sizeof(int));",
        prefix, prefix
    )?;
    writeln!(
        w,
        "            memcpy(new_vs, {}vs, {}stacksize * sizeof(YYSTYPE));",
        prefix, prefix
    )?;
    writeln!(w, "            {}ss = new_ss;", prefix)?;
    writeln!(w, "            {}vs = new_vs;", prefix)?;
    writeln!(w, "        }} else {{")?;
    writeln!(w, "            /* Already on heap: realloc */")?;
    writeln!(
        w,
        "            int *new_ss = (int *) realloc({}ss, new_size * sizeof(int));",
        prefix
    )?;
    writeln!(
        w,
        "            YYSTYPE *new_vs = (YYSTYPE *) realloc({}vs, new_size * sizeof(YYSTYPE));",
        prefix
    )?;
    writeln!(
        w,
        "            if (!new_ss || !new_vs) goto {}exhausted;",
        prefix
    )?;
    writeln!(w, "            {}ss = new_ss;", prefix)?;
    writeln!(w, "            {}vs = new_vs;", prefix)?;
    writeln!(w, "        }}")?;
    writeln!(
        w,
        "        {}vsp = {}vs + {}ssp_offset;",
        prefix, prefix, prefix
    )?;
    writeln!(w, "        {}sslim = {}ss + new_size - 1;", prefix, prefix)?;
    writeln!(w, "        {}stacksize = new_size;", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // POSIX optimization: In consistent states (only one reduce action),
    // skip token read and go directly to reduce
    writeln!(w, "    /* POSIX: skip lookahead in consistent states */")?;
    writeln!(
        w,
        "    if ({}consistent[{}state] && {}defact[{}state]) {{",
        prefix, prefix, prefix, prefix
    )?;
    writeln!(
        w,
        "        {}n = {}defact[{}state] - 1;",
        prefix, prefix, prefix
    )?;
    writeln!(w, "        goto {}reduce;", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Get next token if needed
    writeln!(w, "    if ({}char < 0) {{", prefix)?;
    writeln!(w, "        {}char = {}lex();", prefix, prefix)?;
    writeln!(w, "        if ({}char < 0) {}char = 0;", prefix, prefix)?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "        if ({}debug) {{", prefix)?;
        writeln!(
            w,
            "            int {}tok = {}char < {} ? {}translate[{}char] : {};",
            prefix,
            prefix,
            get_translate_table_size(grammar),
            prefix,
            prefix,
            ERROR_SYMBOL
        )?;
        writeln!(
            w,
            "            fprintf(stderr, \"Reading token %s (%d)\\n\", {}tname[{}tok], {}char);",
            prefix, prefix, prefix
        )?;
        writeln!(w, "        }}")?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Check for acceptance: in final state with $end lookahead
    writeln!(
        w,
        "    if ({}state == YYFINAL && {}char == 0)",
        prefix, prefix
    )?;
    writeln!(w, "        goto {}acceptlab;", prefix)?;
    writeln!(w)?;

    // Lookup action using dense table: action[state * YYNTOKENS + term_idx]
    writeln!(w, "    {{")?;
    writeln!(
        w,
        "        int {}tok = {}char < {} ? {}translate[{}char] : YYERROR_TERM_IDX;",
        prefix,
        prefix,
        get_translate_table_size(grammar),
        prefix,
        prefix
    )?;
    writeln!(
        w,
        "        {}n = {}action[{}state * YYNTOKENS + {}tok];",
        prefix, prefix, prefix, prefix
    )?;
    writeln!(w, "    }}")?;
    writeln!(w)?;
    writeln!(
        w,
        "    /* Action value 0 means consult defact (or accept) */"
    )?;
    writeln!(
        w,
        "    if ({}n == 0) goto {}default_action;",
        prefix, prefix
    )?;
    writeln!(w)?;

    // Handle action
    writeln!(w, "    if ({}n > 0) {{", prefix)?;
    writeln!(w, "        /* Shift */")?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "        if ({}debug) {{", prefix)?;
        writeln!(
            w,
            "            int {}tok = {}char < {} ? {}translate[{}char] : {};",
            prefix,
            prefix,
            get_translate_table_size(grammar),
            prefix,
            prefix,
            ERROR_SYMBOL
        )?;
        writeln!(
            w,
            "            fprintf(stderr, \"Shifting token %s (%d), entering state %d\\n\",",
        )?;
        writeln!(
            w,
            "                    {}tname[{}tok], {}char, {}n);",
            prefix, prefix, prefix, prefix
        )?;
        writeln!(w, "        }}")?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "        {}ssp_offset++;", prefix)?;
    writeln!(w, "        {}vsp++;", prefix)?;
    writeln!(w, "        *{}vsp = {}lval;", prefix, prefix)?;
    writeln!(w, "        {}state = {}n;", prefix, prefix)?;
    // Don't clear yychar when it's EOF (0) - we need to remember we've seen EOF
    // to avoid calling yylex() again in the final state
    writeln!(w, "        if ({}char != 0) {}char = -1;", prefix, prefix)?;
    writeln!(w, "        if ({}errflag > 0) {}errflag--;", prefix, prefix)?;
    writeln!(w, "        goto {}newstate;", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Note: Accept is handled by YYFINAL check at top of loop, not here.
    // Action table value 0 means "consult defact", not Accept.

    // Handle explicit error from %nonassoc conflicts
    writeln!(
        w,
        "    if (YYUNLIKELY({}n == YYTABLE_NINF)) goto {}errlab;",
        prefix, prefix
    )?;
    writeln!(w)?;

    writeln!(w, "    /* Reduce */")?;
    // Decode production number: table stores -(prod + 1), so prod = -n - 1
    writeln!(w, "    {}n = -{}n - 1;", prefix, prefix)?;
    writeln!(w, "    goto {}reduce;", prefix)?;
    writeln!(w)?;

    // Default action
    writeln!(w, "{}default_action:", prefix)?;
    // defact stores production_id + 1, so 0 means no default action
    writeln!(w, "    {}n = {}defact[{}state];", prefix, prefix, prefix)?;
    writeln!(
        w,
        "    if (YYUNLIKELY({}n == 0)) goto {}errlab;",
        prefix, prefix
    )?;
    writeln!(w, "    {}n--;  /* defact stores prod+1 */", prefix)?;
    writeln!(w)?;

    // Reduce
    writeln!(w, "{}reduce:", prefix)?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "    if ({}debug)", prefix)?;
        writeln!(
            w,
            "        fprintf(stderr, \"Reducing by rule %d (%s)\\n\", {}n, {}rule[{}n]);",
            prefix, prefix, prefix
        )?;
        writeln!(w, "#endif")?;
    }

    // Switch on rule number for semantic actions
    writeln!(w, "    switch ({}n) {{", prefix)?;

    for (prod_id, prod) in grammar.productions.iter().enumerate() {
        // Generate case for:
        // - Productions with explicit actions
        // - Productions with empty RHS (no default value)
        // - Productions without actions but with non-empty RHS (POSIX: $$ = $1 default)
        if prod.action.is_some() || !prod.rhs.is_empty() {
            writeln!(w, "    case {}:", prod_id)?;
            writeln!(w, "        {{")?;

            if let Some(ref action) = prod.action {
                // Transform $$ and $n references
                let has_union = grammar.union_def.is_some();
                let transformed =
                    transform_action(action, prod.rhs.len(), grammar, prod, prefix, has_union);
                if !opts.omit_line_directives {
                    writeln!(w, "#line {} \"{}\"", prod.line, opts.grammar_file)?;
                }
                writeln!(w, "        {}", transformed)?;
            } else if !prod.rhs.is_empty() {
                // POSIX: "By default, the value of a rule shall be the value
                // of the first element in it." - implicitly emit $$ = $1
                let rhs_len = prod.rhs.len();
                writeln!(
                    w,
                    "        {}val = {}vsp[{}];  /* $$ = $1 (default) */",
                    prefix,
                    prefix,
                    1 - rhs_len as i32
                )?;
            }

            writeln!(w, "        }}")?;
            writeln!(w, "        break;")?;
        }
    }

    writeln!(w, "    default:")?;
    writeln!(w, "        break;")?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Pop stack and push result
    writeln!(w, "    {}ssp_offset -= {}r2[{}n];", prefix, prefix, prefix)?;
    writeln!(w, "    {}vsp -= {}r2[{}n];", prefix, prefix, prefix)?;
    writeln!(w, "    {}vsp++;", prefix)?;
    writeln!(w, "    *{}vsp = {}val;", prefix, prefix)?;
    writeln!(w)?;

    // Goto using dense table: goto[state * YYNNTS + nt_idx]
    writeln!(w, "    {{")?;
    writeln!(w, "        int {}lhs = {}r1[{}n];", prefix, prefix, prefix)?;
    writeln!(
        w,
        "        int {}idx = {}lhs - YYNTOKENS;  /* nonterminal index */",
        prefix, prefix
    )?;
    writeln!(
        w,
        "        int {}g = {}goto[{}ss[{}ssp_offset] * YYNNTS + {}idx];",
        prefix, prefix, prefix, prefix, prefix
    )?;
    writeln!(
        w,
        "        {}state = ({}g >= 0) ? {}g : {}defgoto[{}idx];",
        prefix, prefix, prefix, prefix, prefix
    )?;
    writeln!(w, "    }}")?;
    writeln!(w, "    {}ssp_offset++;", prefix)?;
    writeln!(w, "    goto {}newstate;", prefix)?;
    writeln!(w)?;

    // Error handling - POSIX compliant algorithm
    // errlab: called when parser detects a syntax error
    writeln!(w, "{}errlab:", prefix)?;
    writeln!(w, "    /* Error detected by parser */")?;
    writeln!(w, "    if ({}errflag == 0) {{", prefix)?;
    writeln!(
        w,
        "        /* First error, or recovered from previous error */"
    )?;
    writeln!(w, "        {}nerrs++;", prefix)?;
    writeln!(w, "        {}error(\"syntax error\");", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w, "    goto {}errlab1;", prefix)?;
    writeln!(w)?;

    // errlab1: YYERROR jumps here (doesn't call yyerror per POSIX)
    writeln!(w, "{}errlab1:", prefix)?;
    writeln!(w, "    if ({}errflag == 3) {{", prefix)?;
    writeln!(
        w,
        "        /* Still trying to recover, discard lookahead */"
    )?;
    writeln!(
        w,
        "        if ({}char == 0) goto {}abortlab;  /* EOF, can't recover */",
        prefix, prefix
    )?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "        if ({}debug) {{", prefix)?;
        writeln!(
            w,
            "            int {}tok = {}char < {} ? {}translate[{}char] : {};",
            prefix,
            prefix,
            get_translate_table_size(grammar),
            prefix,
            prefix,
            ERROR_SYMBOL
        )?;
        writeln!(
            w,
            "            fprintf(stderr, \"Error recovery: discarding token %s (%d)\\n\", {}tname[{}tok], {}char);",
            prefix, prefix, prefix
        )?;
        writeln!(w, "        }}")?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "        {}char = -1;", prefix)?;
    writeln!(w, "        goto {}newstate;", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Error recovery: pop until we can shift error token
    writeln!(w, "    /* Pop stack until we can shift the error token */")?;
    writeln!(w, "    {}errflag = 3;", prefix)?;
    writeln!(w, "    for (;;) {{")?;
    // Use dense action table lookup for error token
    writeln!(
        w,
        "        {}n = {}action[{}state * YYNTOKENS + YYERROR_TERM_IDX];",
        prefix, prefix, prefix
    )?;
    // Check if action is a shift (positive value)
    writeln!(w, "        if ({}n > 0) {{", prefix)?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "            if ({}debug)", prefix)?;
        writeln!(
            w,
            "                fprintf(stderr, \"Shifting error token, entering state %d\\n\", {}n);",
            prefix
        )?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "            /* Shift the error token */")?;
    writeln!(w, "            {}ssp_offset++;", prefix)?;
    writeln!(w, "            {}vsp++;", prefix)?;
    writeln!(w, "            {}state = {}n;", prefix, prefix)?;
    writeln!(w, "            goto {}newstate;", prefix)?;
    writeln!(w, "        }}")?;
    writeln!(
        w,
        "        if ({}ssp_offset <= 0) goto {}abortlab;",
        prefix, prefix
    )?;
    if opts.debug_enabled {
        writeln!(w, "#if YYDEBUG")?;
        writeln!(w, "        if ({}debug)", prefix)?;
        writeln!(
            w,
            "            fprintf(stderr, \"Error recovery: popping state %d\\n\", {}state);",
            prefix
        )?;
        writeln!(w, "#endif")?;
    }
    writeln!(w, "        {}ssp_offset--;", prefix)?;
    writeln!(w, "        {}vsp--;", prefix)?;
    writeln!(
        w,
        "        {}state = {}ss[{}ssp_offset];",
        prefix, prefix, prefix
    )?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Accept
    writeln!(w, "{}acceptlab:", prefix)?;
    writeln!(w, "    {}result = 0;", prefix)?;
    writeln!(w, "    goto {}cleanup;", prefix)?;
    writeln!(w)?;

    // Abort
    writeln!(w, "{}abortlab:", prefix)?;
    writeln!(w, "    {}result = 1;", prefix)?;
    writeln!(w, "    goto {}cleanup;", prefix)?;
    writeln!(w)?;

    // Stack exhausted
    writeln!(w, "{}exhausted:", prefix)?;
    writeln!(w, "    {}error(\"parser stack exhausted\");", prefix)?;
    writeln!(w, "    {}result = 2;", prefix)?;
    writeln!(w)?;

    // Cleanup
    writeln!(w, "{}cleanup:", prefix)?;
    // Only free if we migrated to heap (hybrid stack allocation)
    writeln!(w, "    if ({}ss != {}ssa) {{", prefix, prefix)?;
    writeln!(w, "        free({}ss);", prefix)?;
    writeln!(w, "        free({}vs);", prefix)?;
    writeln!(w, "    }}")?;
    writeln!(w, "    return {}result;", prefix)?;
    writeln!(w, "}}")?;
    writeln!(w)?;

    Ok(())
}

/// Transform semantic action: replace $$ and $n with stack references
///
/// POSIX defines the following pseudo-variables:
/// - `$$` : The value of the action (LHS)
/// - `$number` : Value of component N in the RHS (1-indexed for RHS, 0 or negative for left context)
/// - `$<tag>$` : Like $$ but with explicit type tag
/// - `$<tag>number` : Like $number but with explicit type tag
///
/// For $n where n <= 0:
/// - `$0` refers to the name immediately preceding the leftmost symbol of the current rule
/// - `$-1` refers to the symbol to its left, etc.
///
/// These access values on the parser's stack preceding the current rule.
fn transform_action(
    action: &str,
    rhs_len: usize,
    grammar: &Grammar,
    prod: &crate::grammar::Production,
    prefix: &str,
    has_union: bool,
) -> String {
    let mut result = String::new();
    let mut chars = action.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '$' {
            match chars.peek() {
                Some('$') => {
                    chars.next();
                    // Use LHS type if available
                    if let Some(ref tag) = grammar.symbols[prod.lhs].tag {
                        result.push_str(&format!("({}val.{})", prefix, tag));
                    } else {
                        // P1-3: POSIX allows warning when %union used but type undetermined
                        if has_union {
                            let lhs_name = grammar.symbol_name(prod.lhs);
                            diag::warning(
                                diag::Position::line_only(prod.line as u32),
                                &format!(
                                    "$$ has no declared type; '{}' lacks a %type declaration",
                                    lhs_name
                                ),
                            );
                        }
                        result.push_str(&format!("({}val)", prefix));
                    }
                }
                Some('<') => {
                    // $<tag>$ or $<tag>n - explicit type tag
                    chars.next();
                    let mut tag = String::new();
                    while let Some(&tc) = chars.peek() {
                        if tc == '>' {
                            chars.next();
                            break;
                        }
                        tag.push(tc);
                        chars.next();
                    }
                    // Now check what follows the tag
                    match chars.peek() {
                        Some('$') => {
                            chars.next();
                            result.push_str(&format!("({}val.{})", prefix, tag));
                        }
                        Some(&c) if c.is_ascii_digit() || c == '-' => {
                            // Parse the number (can be negative)
                            let mut num_str = String::new();
                            if c == '-' {
                                num_str.push('-');
                                chars.next();
                            }
                            while let Some(&d) = chars.peek() {
                                if d.is_ascii_digit() {
                                    num_str.push(d);
                                    chars.next();
                                } else {
                                    break;
                                }
                            }
                            let n: i32 = num_str.parse().unwrap_or(0);
                            // Generate stack reference with explicit tag
                            let stack_ref =
                                generate_stack_reference(n, rhs_len, Some(&tag), prefix);
                            result.push_str(&stack_ref);
                        }
                        _ => {
                            // Invalid syntax, pass through
                            result.push_str("$<");
                            result.push_str(&tag);
                            result.push('>');
                        }
                    }
                }
                Some(&c) if c.is_ascii_digit() || c == '-' => {
                    // $n or $-n - reference to stack value
                    let mut num_str = String::new();
                    if c == '-' {
                        num_str.push('-');
                        chars.next();
                    }
                    while let Some(&d) = chars.peek() {
                        if d.is_ascii_digit() {
                            num_str.push(d);
                            chars.next();
                        } else {
                            break;
                        }
                    }
                    let n: i32 = num_str.parse().unwrap_or(0);

                    // Try to determine type from RHS symbol (only for positive indices within RHS)
                    let (sym_tag, sym_name) = if n > 0 && (n as usize) <= rhs_len {
                        let sym_id = prod.rhs[n as usize - 1];
                        (
                            grammar.symbols[sym_id].tag.clone(),
                            Some(grammar.symbol_name(sym_id).to_string()),
                        )
                    } else {
                        // For $0, $-1, etc., no automatic type inference
                        (None, None)
                    };

                    // P1-3: POSIX allows warning when %union used but type undetermined
                    if has_union && sym_tag.is_none() && n > 0 && (n as usize) <= rhs_len {
                        if let Some(ref name) = sym_name {
                            diag::warning(
                                diag::Position::line_only(prod.line as u32),
                                &format!(
                                    "${} has no declared type; '{}' lacks a %type declaration",
                                    n, name
                                ),
                            );
                        }
                    }

                    let stack_ref =
                        generate_stack_reference(n, rhs_len, sym_tag.as_deref(), prefix);
                    result.push_str(&stack_ref);
                }
                _ => {
                    result.push('$');
                }
            }
        } else {
            result.push(c);
        }
    }

    result
}

/// Generate a stack reference for $n syntax
///
/// For a rule with `rhs_len` symbols on the RHS:
/// - $1 refers to {prefix}vsp[-(rhs_len-1)] (first RHS symbol)
/// - $rhs_len refers to {prefix}vsp[0] (last RHS symbol)
/// - $0 refers to {prefix}vsp[-rhs_len] (symbol before the rule on the stack)
/// - $-1 refers to {prefix}vsp[-(rhs_len+1)] (two symbols before the rule)
///
/// The formula: offset = -(rhs_len - n) = n - rhs_len
fn generate_stack_reference(n: i32, rhs_len: usize, tag: Option<&str>, prefix: &str) -> String {
    // Calculate the stack offset
    // {prefix}vsp points to the top of the value stack (last RHS symbol)
    // For $n: offset from {prefix}vsp = n - rhs_len
    // Examples with rhs_len=3:
    //   $1 -> offset = 1-3 = -2 (first RHS symbol)
    //   $2 -> offset = 2-3 = -1
    //   $3 -> offset = 3-3 = 0 (last RHS symbol, top of stack)
    //   $0 -> offset = 0-3 = -3 (one before the rule)
    //   $-1 -> offset = -1-3 = -4 (two before the rule)
    let offset = n - rhs_len as i32;

    if let Some(tag) = tag {
        if offset == 0 {
            format!("({}vsp[0].{})", prefix, tag)
        } else {
            format!("({}vsp[{}].{})", prefix, offset, tag)
        }
    } else if offset == 0 {
        format!("({}vsp[0])", prefix)
    } else {
        format!("({}vsp[{}])", prefix, offset)
    }
}

/// Generate header file (y.tab.h)
fn generate_header_file(path: &str, opts: &Options, grammar: &Grammar) -> Result<(), YaccError> {
    let file = File::create(path)
        .map_err(|e| YaccError::Io(format!("cannot create '{}': {}", path, e)))?;
    let mut w = BufWriter::new(file);

    writeln!(
        w,
        "/* Header file generated by yacc from posixutils-rs v{} */",
        env!("CARGO_PKG_VERSION")
    )?;
    writeln!(w)?;

    // Token definitions
    generate_token_defines(&mut w, grammar, opts)?;
    writeln!(w)?;

    // YYSTYPE definition
    if let Some(ref union_def) = grammar.union_def {
        writeln!(w, "#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED")?;
        if !opts.omit_line_directives {
            writeln!(w, "#line {} \"{}\"", union_def.line, opts.grammar_file)?;
        }
        writeln!(w, "typedef union YYSTYPE")?;
        writeln!(w, "{}", union_def.code)?;
        writeln!(w, " YYSTYPE;")?;
        writeln!(w, "# define YYSTYPE_IS_DECLARED 1")?;
        writeln!(w, "#endif")?;
    } else {
        writeln!(
            w,
            r#"#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_DECLARED 1
#endif
"#
        )?;
    }

    // External yylval
    writeln!(w, "extern YYSTYPE {}lval;", opts.sym_prefix)?;

    w.flush()
        .map_err(|e| YaccError::Io(format!("error writing '{}': {}", path, e)))?;

    Ok(())
}

/// Generate description file (y.output)
fn generate_description_file(
    path: &str,
    grammar: &Grammar,
    lalr: &LALRAutomaton,
) -> Result<(), YaccError> {
    let file = File::create(path)
        .map_err(|e| YaccError::Io(format!("cannot create '{}': {}", path, e)))?;
    let mut w = BufWriter::new(file);

    writeln!(w, "Grammar")?;
    writeln!(w)?;

    // List rules
    for (i, prod) in grammar.productions.iter().enumerate() {
        write!(w, "  {:3} {}: ", i, grammar.symbol_name(prod.lhs))?;
        if prod.rhs.is_empty() {
            writeln!(w, "/* empty */")?;
        } else {
            for &sym in &prod.rhs {
                write!(w, "{} ", grammar.symbol_name(sym))?;
            }
            writeln!(w)?;
        }
    }
    writeln!(w)?;

    // List terminals
    writeln!(w, "Terminals, with rules where they appear")?;
    writeln!(w)?;
    for (id, sym) in grammar.symbols.iter().enumerate() {
        if sym.is_terminal {
            write!(w, "  {} ({})", sym.name, sym.token_number.unwrap_or(0))?;
            let prods: Vec<usize> = grammar
                .productions
                .iter()
                .enumerate()
                .filter(|(_, p)| p.rhs.contains(&id))
                .map(|(i, _)| i)
                .collect();
            if !prods.is_empty() {
                write!(w, " ")?;
                for (i, p) in prods.iter().enumerate() {
                    if i > 0 {
                        write!(w, " ")?;
                    }
                    write!(w, "{}", p)?;
                }
            }
            writeln!(w)?;
        }
    }
    writeln!(w)?;

    // List non-terminals
    writeln!(w, "Nonterminals, with rules where they appear")?;
    writeln!(w)?;
    for (id, sym) in grammar.symbols.iter().enumerate() {
        if !sym.is_terminal {
            write!(w, "  {}", sym.name)?;
            let lhs_prods: Vec<usize> = grammar
                .productions
                .iter()
                .enumerate()
                .filter(|(_, p)| p.lhs == id)
                .map(|(i, _)| i)
                .collect();
            let rhs_prods: Vec<usize> = grammar
                .productions
                .iter()
                .enumerate()
                .filter(|(_, p)| p.rhs.contains(&id))
                .map(|(i, _)| i)
                .collect();

            writeln!(w)?;
            if !lhs_prods.is_empty() {
                write!(w, "    on left:")?;
                for p in &lhs_prods {
                    write!(w, " {}", p)?;
                }
                writeln!(w)?;
            }
            if !rhs_prods.is_empty() {
                write!(w, "    on right:")?;
                for p in &rhs_prods {
                    write!(w, " {}", p)?;
                }
                writeln!(w)?;
            }
        }
    }
    writeln!(w)?;

    // State descriptions
    writeln!(w, "State descriptions")?;
    writeln!(w)?;

    for state in &lalr.lr0.states {
        writeln!(w, "State {}", state.id)?;
        writeln!(w)?;

        // Items
        for &item in &state.items {
            let prod = &grammar.productions[item.production];
            write!(w, "    {} -> ", grammar.symbol_name(prod.lhs))?;
            for (i, &sym) in prod.rhs.iter().enumerate() {
                if i == item.dot {
                    write!(w, ". ")?;
                }
                write!(w, "{} ", grammar.symbol_name(sym))?;
            }
            if item.dot >= prod.rhs.len() {
                write!(w, ".")?;
            }
            writeln!(w)?;
        }
        writeln!(w)?;

        // Actions
        if let Some(actions) = lalr.action_table.get(state.id) {
            for (&sym, action) in actions {
                let action_str = match action {
                    Action::Shift(s) => format!("shift, and go to state {}", s),
                    Action::Reduce(r) => format!("reduce using rule {}", r),
                    Action::Accept => "accept".to_string(),
                    Action::Error => "error".to_string(),
                };
                writeln!(w, "    {}  {}", grammar.symbol_name(sym), action_str)?;
            }
        }

        // Gotos
        if let Some(gotos) = lalr.goto_table.get(state.id) {
            for (&sym, &target) in gotos {
                writeln!(
                    w,
                    "    {}  go to state {}",
                    grammar.symbol_name(sym),
                    target
                )?;
            }
        }

        writeln!(w)?;
    }

    // Conflict summary
    // Grammar summary (per POSIX: "Limits for internal tables... shall also be reported")
    writeln!(w)?;
    writeln!(w, "Grammar summary")?;
    writeln!(w, "  Terminals:     {:5}", grammar.num_terminals)?;
    writeln!(w, "  Non-terminals: {:5}", grammar.num_nonterminals)?;
    writeln!(w, "  Rules:         {:5}", grammar.productions.len())?;
    writeln!(w, "  States:        {:5}", lalr.lr0.states.len())?;
    writeln!(
        w,
        "  Actions:       {:5}",
        lalr.action_table.iter().map(|a| a.len()).sum::<usize>()
    )?;

    let (sr, rr) = lalr.count_conflicts();
    if sr > 0 || rr > 0 {
        writeln!(w)?;
        writeln!(w, "Conflicts:")?;
        if sr > 0 {
            writeln!(w, "  {} shift/reduce", sr)?;
        }
        if rr > 0 {
            writeln!(w, "  {} reduce/reduce", rr)?;
        }

        // P3-2: Detailed conflict information per state
        writeln!(w)?;
        writeln!(w, "Conflict details:")?;

        // Group conflicts by state
        let mut by_state: BTreeMap<usize, Vec<(usize, &Vec<Action>)>> = BTreeMap::new();
        for ((state, sym), actions) in &lalr.conflicts {
            by_state.entry(*state).or_default().push((*sym, actions));
        }

        for (state_id, conflicts) in by_state {
            writeln!(w, "  State {}:", state_id)?;
            for (sym_id, actions) in conflicts {
                let sym_name = grammar.symbol_name(sym_id);
                let shifts: Vec<_> = actions
                    .iter()
                    .filter_map(|a| match a {
                        Action::Shift(s) => Some(*s),
                        _ => None,
                    })
                    .collect();
                let reduces: Vec<_> = actions
                    .iter()
                    .filter_map(|a| match a {
                        Action::Reduce(r) => Some(*r),
                        _ => None,
                    })
                    .collect();

                if !shifts.is_empty() && !reduces.is_empty() {
                    write!(w, "    {} : shift/reduce (", sym_name)?;
                    write!(w, "shift {}", shifts[0])?;
                    for r in &reduces {
                        write!(w, ", reduce {}", r)?;
                    }
                    writeln!(w, ")")?;
                } else if reduces.len() > 1 {
                    write!(w, "    {} : reduce/reduce (", sym_name)?;
                    for (i, r) in reduces.iter().enumerate() {
                        if i > 0 {
                            write!(w, ", ")?;
                        }
                        write!(w, "reduce {}", r)?;
                    }
                    writeln!(w, ")")?;
                }
            }
        }
    }

    w.flush()
        .map_err(|e| YaccError::Io(format!("error writing '{}': {}", path, e)))?;

    Ok(())
}

impl From<std::io::Error> for YaccError {
    fn from(e: std::io::Error) -> Self {
        YaccError::Io(e.to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_stack_reference_positive() {
        // For a rule with 3 RHS symbols:
        // $1 -> yyvsp[-2], $2 -> yyvsp[-1], $3 -> yyvsp[0]
        assert_eq!(generate_stack_reference(1, 3, None, "yy"), "(yyvsp[-2])");
        assert_eq!(generate_stack_reference(2, 3, None, "yy"), "(yyvsp[-1])");
        assert_eq!(generate_stack_reference(3, 3, None, "yy"), "(yyvsp[0])");
    }

    #[test]
    fn test_generate_stack_reference_zero_and_negative() {
        // For a rule with 3 RHS symbols:
        // $0 -> yyvsp[-3] (one before the rule)
        // $-1 -> yyvsp[-4] (two before the rule)
        // $-2 -> yyvsp[-5]
        assert_eq!(generate_stack_reference(0, 3, None, "yy"), "(yyvsp[-3])");
        assert_eq!(generate_stack_reference(-1, 3, None, "yy"), "(yyvsp[-4])");
        assert_eq!(generate_stack_reference(-2, 3, None, "yy"), "(yyvsp[-5])");
    }

    #[test]
    fn test_generate_stack_reference_with_tag() {
        // With explicit type tags
        assert_eq!(
            generate_stack_reference(1, 2, Some("ival"), "yy"),
            "(yyvsp[-1].ival)"
        );
        assert_eq!(
            generate_stack_reference(2, 2, Some("ival"), "yy"),
            "(yyvsp[0].ival)"
        );
        assert_eq!(
            generate_stack_reference(0, 2, Some("sval"), "yy"),
            "(yyvsp[-2].sval)"
        );
        assert_eq!(
            generate_stack_reference(-1, 2, Some("sval"), "yy"),
            "(yyvsp[-3].sval)"
        );
    }

    #[test]
    fn test_generate_stack_reference_empty_rhs() {
        // For an empty rule (epsilon production), rhs_len = 0
        // $0 -> yyvsp[0] (the symbol just before where we are)
        // Actually for empty RHS, $0 refers to yyvsp[0 - 0] = yyvsp[0]
        // which is the top of the stack before reduction
        assert_eq!(generate_stack_reference(0, 0, None, "yy"), "(yyvsp[0])");
        assert_eq!(generate_stack_reference(-1, 0, None, "yy"), "(yyvsp[-1])");
    }

    #[test]
    fn test_generate_stack_reference_single_rhs() {
        // For a rule with 1 RHS symbol:
        // $1 -> yyvsp[0] (the only symbol)
        // $0 -> yyvsp[-1] (one before)
        assert_eq!(generate_stack_reference(1, 1, None, "yy"), "(yyvsp[0])");
        assert_eq!(generate_stack_reference(0, 1, None, "yy"), "(yyvsp[-1])");
        assert_eq!(generate_stack_reference(-1, 1, None, "yy"), "(yyvsp[-2])");
    }

    #[test]
    fn test_generate_stack_reference_custom_prefix() {
        // Test with a custom prefix (for -p option)
        assert_eq!(generate_stack_reference(1, 2, None, "foo"), "(foovsp[-1])");
        assert_eq!(generate_stack_reference(2, 2, None, "foo"), "(foovsp[0])");
        assert_eq!(
            generate_stack_reference(1, 2, Some("ival"), "my"),
            "(myvsp[-1].ival)"
        );
    }
}
